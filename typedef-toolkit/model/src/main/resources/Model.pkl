/* SPDX-License-Identifier: Apache-2.0
   Copyright 2024 Atlan Pte. Ltd. */

/// Template for defining a custom model in Atlan.
///
/// | Variable | | Usage |
/// |---|---|---|
/// | **t** | | A prefix for the types in the custom model (CamelCased) |
/// | **a** | | A prefix for the attributes in the custom model (lowerCamelCased) |
/// | **[shared][ReusableElements]** | | An abstract model defining common attributes or structures for other assets in the custom model |
/// | **[customTypes][CustomAssetType]** | | A list of custom entity types that can be instantiated in the custom model |
@ModuleInfo { minPklVersion = "0.25.1" }
module com.atlan.typedef.Model

/// Prefix to namespace all **types** in the custom model.
///
/// This should be in CamelCase.
t: String

/// Prefix to namespace all **attributes** in the custom model.
///
/// This should be in lowerCamelCase.
a: String = t.toLowerCase()

/// [ReusableElements] defining metadata shared across other types in the custom model.
shared: ReusableElements

/// One or more [CustomAssetType]s that can be instantiated in the custom model.
///
/// Remember in Pkl to define a list:
/// ```
/// customTypes {
///   new {
///     ...
///   }
///   new {
///     ...
///   }
///   ...
/// }
/// ```
customTypes: Listing<CustomAssetType>?

/// Validates the provided string value is in PascalCase.
local const PascalCase = (str) -> str.matches(Regex("[A-Z][a-zA-Z0-9]*"))

/// Validates the provided string value is in camelCase.
local const camelCase = (str) -> str.matches(Regex("[a-z][a-zA-Z0-9]*"))

/// Validates the provided string value is in snake_case.
local const lower_snake_case = (str) -> str.matches(Regex("[a-z0-9_]*"))

/// Translate the provided text into lower_snake_case.
/// - `text` the text to translate
const function getLowerSnakeCase(text: String): String = getSnakeCase(text).toLowerCase()
local const function getSnakeCase(text: String): String = text.replaceAll("_", "").replaceAll(Regex("([A-Z]+)([A-Z][a-z])"), "$1_$2").replaceAll(Regex("([a-z])([A-Z])"), "$1_$2")

/// Type of an attribute.
/// - `string`
/// - `int` for small whole numbers
/// - `long` for potentially large whole numbers
/// - `float` for decimal numbers
/// - `boolean`
/// - `date` for date and time
/// - `enum` for an enumeration, in which case you must also specify `enumName` as an additional property for the attribute
typealias DataType = "string"|"int"|"long"|"float"|"boolean"|"date"|"enum"

/// Type of index in Elastic for this attribute.
/// - `default`
/// - `keyword` allows exact matches and "starts-with" searches
/// - `text` allows full-text searches (tokenization of the value)
/// - `both` allows both exact matches and full-text searches
typealias IndexType = "default"|"keyword"|"text"|"both"

/// Type of tag propagation through the relationship.
/// - `NONE` tags will not be propagated through this relationship
/// - `ONE_TO_TWO` tags will be propagated from endDef1 to endDef2
/// - `TWO_TO_ONE` tags will be propagated from endDef2 to endDef1
/// - `BOTH` tags will be propagated in both directions
typealias PropagationType = "NONE"|"ONE_TO_TWO"|"TWO_TO_ONE"|"BOTH"

/// Metadata shared across other types in the custom model.
///
/// | Variable | | Usage |
/// |---|---|---|
/// | **[supertypeDefinition][EntityDef]** | | Define a single entity type all others will inherit from |
/// | **[enumerations][EnumDef]** | | (Optional) enumerations that are reused by a number of custom asset types in the model |
/// | **[structures][StructDef]** | | (Optional) complex, embeddable types that are reused by a number of custom assets in the model |
class ReusableElements {

  /// Singular [entity type][EntityDef] that should be the supertype for all other entity types in the custom model.
  supertypeDefinition: EntityDef

  /// (Optional) [Enumerations][EnumDef] that should be reused by a number of custom assets in the model.
  enumerations: Listing<EnumDef>?

  /// (Optional) Structures that define [complex, embeddable types][StructDef] that should be reused by a number of custom assets in the model.
  structures: Listing<StructDef>?
}

/// A specific type that can be instantiated within the custom model.
///
/// | Variable | | Usage |
/// |---|---|---|
/// | **[assetDefinition][EntityDef]** | | Define a single entity type that can be instantiated |
/// | **[enumerations][EnumDef]** | | (Optional) enumerations that are specific to the custom entity type |
/// | **[structures][StructDef]** | | (Optional) complex, embeddable types that are specific to the custom entity type |
/// | **[relationships][RelationshipDef]** | | (Optional) relationships that are specific to the custom entity type |
class CustomAssetType {

  /// Singular [entity type][EntityDef] that should be included in the custom model.
  assetDefinition: EntityDef

  /// (Optional) [Enumerations][EnumDef] that are specific to the custom asset.
  enumerations: Listing<EnumDef>?

  /// (Optional) Structures that define [complex, embeddable types][StructDef] that are specific to the custom asset.
  structures: Listing<StructDef>?

  /// (Optional) [Relationships][RelationshipDef] that are specific to the custom asset.
  relationships: Listing<RelationshipDef>?
}

open class TypeDef {

  /// Name for the new type.
  name: String

  /// Fixed category for the type -- this will be set automatically, and cannot be overridden.
  fixed category: String = "ERROR"

  /// Explanation of the type definition.
  description: String

  /// Overall namespace for the type definition. This should be left as-is (`atlan`) unless told otherwise.
  serviceType: String = "atlan"

  /// Version number for the type definition. This should be incremented any time you are modifying an existing type definition.
  typeVersion: String = "1.0"

  /// (Optional) List of [attributes][AttributeDef] for the type definition. Remember that attributes from any supertypes will automatically be
  /// inherited and should not be listed again here in the subtype.
  attributeDefs: Listing<AttributeDef>?
}

/// Definition of a type of custom entity.
///
/// | Variable | | Usage |
/// |---|---|---|
/// | **name** | | Unique name of the entity type, which should start with `\(t)` |
/// | **description** | | Explanation of the custom entity type |
/// | **superTypes** | | At least one super type, typically the type defined in the `supertypeDefinition` |
/// | **[attributeDefs][AttributeDef]** | | (Optional) List of attributes unique to this custom entity type |
class EntityDef extends TypeDef {
  name: String(PascalCase)

  /// Category is set automatically and fixed (should not be changed).
  fixed category = "ENTITY"

  /// List of super types for the entity definition. This should include the supertype for the custom model in any custom
  /// assets, and usually the supertype of `Catalog` for the supertype definition.
  superTypes: Listing<String>(length > 0)
}

/// Definition of a single attribute within a type definition.
///
/// | Variable | | Usage |
/// |---|---|---|
/// | **name** | | Unique name of the attribute, which should start with `\(a)` |
/// | **description** | | Explanation of the attribute |
/// | **type** | | Type of the attribute, either a primitive (`string`, `int`, `float`, `boolean`, `date`) or `enum` |
/// | **enumName** | | (Optional) Name of the enumeration this attribute should use, if type is `enum` |
/// | **multiValued** | | (Optional) Whether this attribute should allow multiple values (true) or not (false - default) |
/// | **defaultValue** | | (Optional) Default value for the attribute |
/// | **isDefaultValueNull** | | (Optional) Whether the attribute has a default value of being empty (true) or not (false) |
/// | **isOptional** | | (Optional) Whether the attribute is mandatory (false) or optional (true - default) |
/// | **valuesMinCount** | | (Optional) Minimum number of values the attribute should have |
/// | **valuesMaxCount** | | (Optional) Maximum number of values the attribute should have |
/// | **isUnique** | | (Optional) Whether the attribute is unique (true) or not (false - default) |
/// | **isIndexable** | | (Optional) Whether the attribute is indexed in-memory via Cassandra (true) or not (false - default) |
/// | **includeInNotification** | | (Optional) Whether the attribute should generate a notification when its value changes (true - default) or not (false) |
/// | **skipScrubbing** | | (Optional) TBC |
/// | **searchWeight** | | (Optional) TBC |
/// | **indexAs** | | (Optional) What kind of index(es) to create in Elastic for this attribute |
open class AttributeDef {
  local resolvedType = if (type == "enum") enumName else type

  /// Name for the new attribute.
  name: String(camelCase)

  /// Explanation of the attribute (what data it holds, how it is used).
  description: String

  /// Type of the attribute -- this will be set automatically from the
  /// `type`, `multiValued` and `enumName` parameters.
  fixed typeName = if (multiValued) "array<\(resolvedType)>" else resolvedType

  /// Type of the attribute. This should be either:
  /// - A primitive Atlan type.
  /// - The special value `enum` to indicate an enumeration. In this case, you must also specify `enumName` as an additional property for the attribute.</li>
  hidden type: DataType

  /// Whether this attribute should allow multiple values (true) or not (false - default).
  hidden multiValued: Boolean = false

  /// Name of the enumeration that this attribute should use, if you have specified type = `enum`.
  hidden enumName: String(if (type == "enum") this != "" else true) = ""

  /// Default value for the attribute.
  defaultValue: String?

  /// Indicates whether the attribute has a default value of being empty (true) or not (false).
  isDefaultValueNull: Boolean?

  /// Indicates whether the attribute is mandatory (false) or optional (true - default).
  isOptional: Boolean = true

  /// Specifies whether the attribute is single or multivalued -- this will be set automatically
  /// from the `multiValued` parameter.
  fixed cardinality = if (multiValued) "SET" else "SINGLE"

  /// Minimum number of values the attribute should have.
  valuesMinCount: Int32? = if (!multiValued) 0 else null

  /// Maximum number of values the attribute should have.
  valuesMaxCount: Int32? = if (!multiValued) 1 else null

  /// Whether the attribute is unique (true) or not (false - default).
  isUnique: Boolean = false

  /// Whether the attribute is indexed in-memory via Cassandra (true) or not (false - default).
  isIndexable: Boolean = false

  /// Whether the attribute should generate a notification when its value changes (true - default) or not (false).
  includeInNotification: Boolean = true

  /// TBC
  skipScrubbing: Boolean = true

  /// TBC
  searchWeight: Int32?

  /// What kind of index(es) to create in Elastic for this attribute.
  /// - `keyword` creates only a keyword (exact match) index
  /// - `text` creates only a textual (tokenized) index
  /// - `both` creates both a keyword and a textual index
  hidden indexAs: IndexType = "default"

  /// Details to set a keyword index in Elastic -- this is managed automatically through setting
  /// `indexAs`.
  fixed indexType = if (indexAs == "keyword" || (indexAs == "default" && (type == "string" || type == "enum"))) "STRING" else null

  /// Details to set a textual index in Elastic -- this is managed automatically through setting
  /// `indexAs`.
  fixed indexTypeESConfig: Mapping<String, String>? = if (indexAs == "text" || indexAs == "both") new Mapping {
    ["analyzer"] = "atlan_text_analyzer"
  } else null

  /// Details to set a textual index in Elastic -- this is managed automatically through setting
  /// `indexAs`.
  fixed indexTypeESFields: Mapping<String, Mapping<String, String>>? = if (indexAs == "both") new Mapping {
    ["keyword"] = new Mapping {
      ["type"] = "keyword"
      ["analyzer"] = "atlan_normalizer"
    }
  } else null
}

/// Definition of a relationship between two entity types.
///
/// You should generally define these only on any child entity types, pointing to their parent entity type.
/// (But in any case, a given relationship should only ever be defined once in the model, not repeated across
/// entity types.)
///
/// Note: The name, label, and category of the relationship will all be set automatically based on the other parameters.
///
/// | Variable | | Usage |
/// |---|---|---|
/// | description | | Explanation of the relationship |
/// | **[endDef1][RelationshipEndDef]** | | Definition for the first endpoint of the relationship |
/// | **[endDef2][RelationshipEndDef]** | | Definition for the second endpoint of the relationship |
/// | **propagateTags** | | (Optional) Whether Atlan tags should propagate throguh this relationship or not (default: not) |
/// | **[relationshipAttributeDefs][RelationshipAttributeDef]** | | (Optional) List of attributes that can be managed on each instance of the relationship |
class RelationshipDef extends TypeDef {

  /// Category is set automatically and fixed (should not be changed).
  fixed category = "RELATIONSHIP"

  /// Definition for the first [endpoint][RelationshipEndDef] of the relationship.
  endDef1: RelationshipEndDef

  /// Definition for the second [endpoint][RelationshipEndDef] of the relationship.
  endDef2: RelationshipEndDef

  /// Whether Atlan tags should propagate through this relationship, and if so in which direction(s):
  /// - `NONE` tags will not be propagated through this relationship (default)
  /// - `ONE_TO_TWO` tags will be propagated from endDef1 to endDef2
  /// - `TWO_TO_ONE` tags will be propagated from endDef2 to endDef1
  /// - `BOTH` tags will be propagated in both directions
  propagateTags: PropagationType = "NONE"

  /// Unique name for the relationship type definition -- this will be generated automatically
  /// based on the `endDef1` and `endDef2` parameters.
  name: String(lower_snake_case) = "\(getLowerSnakeCase(endDef2.name))_\(getLowerSnakeCase(endDef1.name))"

  /// Unique label for the relationship type definition -- this will be generated automatically
  /// based on the `endDef1` parameter.
  fixed relationshipLabel = "__\(endDef1.type).\(endDef1.name)"

  /// Kind of relationship -- this will be set automatically based on whether either endDef is defined as
  /// a container.
  fixed relationshipCategory = if (endDef1.isContainer || endDef2.isContainer) "AGGREGATION" else "ASSOCIATION"

  /// (Optional) List of attributes that can be managed on each instance of the relationship.
  relationshipAttributeDefs: Listing<RelationshipAttributeDef>?
}

/// Definition of one end of a relationship.
///
/// Note: The cardinality of the relationship endpoint will be set automatically based on the other parameters.
///
/// | Variable | | Usage |
/// |---|---|---|
/// | **type** | | Name of the custom entity type at this end of the relationship |
/// | **name** | | Name of the attribute on this end of the relationship, that refers to the *other* entity type (other end of the relationship) |
/// | **description** | | Explanation of the relationship from this end of it |
/// | **isContainer** | | (Optional) Whether this end of the relationship is a container ("owns" the other end's assets) (default: false) |
/// | **isLegacyAttribute** | | (Optional) TBC |
class RelationshipEndDef {

  /// Name of the custom entity type at this end of the relationship.
  type: String

  /// Name of the attribute on this end of the relationship, that refers to the *other* entity type (other end of the relationship).
  name: String(camelCase)

  /// Description of the relationship from this end of it.
  description: String

  /// Whether this end of the relationship is a container ("owns" the other end's assets) (default: false).
  isContainer: Boolean = false

  /// TBC
  isLegacyAttribute: Boolean = false

  /// Cardinality of this end of the relationship -- this will be set automatically based on `isContainer`.
  fixed cardinality = if (isContainer) "SET" else "SINGLE"
}

/// Definition of an attribute that can be managed on each instance of the relationship.
///
/// | Variable | | Usage |
/// |---|---|---|
/// | **name** | | Name of the attribute that represents this end of the relationship |
/// | **description** | | Explanation of the relationship from this end of it |
/// | **type** | | Name of the custom entity type this relationship points to (the type at the other end of the relationship) |
/// | **isContainer** | | (Optional) Whether this end of the relationship is a container ("owns" the other end's assets) (default: false) |
/// | **isLegacyAttribute** | | (Optional) TBC |
class RelationshipAttributeDef extends AttributeDef {

  /// TBC
  isLegacyAttribute: Boolean?

  /// TBC
  relationshipTypeName: String?
}

/// Definition of an enumeration of valid values.
///
/// | Variable | | Usage |
/// |---|---|---|
/// | **name** | | Unique name of the enumeration of values, which should usually start with `\(t)` |
/// | **description** | | Explanation of the enumeration of values |
/// | **[elementDefs][EnumElementDef]** | | List of valid values for the enumeration |
class EnumDef extends TypeDef {

  /// Category is set automatically and fixed (should not be changed).
  fixed category = "ENUM"

  /// Overall namespace for the type definition. This should be left as-is (`atlas_core`) to avoid the enumeration
  /// appearing as one defined via the UI.
  serviceType = "atlas_core"

  /// List of valid values for the enumeration.
  elementDefs: Listing<EnumElementDef>
}

/// Definition of a single valid value for an enumeration.
///
/// | Variable | | Usage |
/// |---|---|---|
/// | **ordinal** | | Position of the valid value within the list of valid values (must be unique, sequential) |
/// | **value** | | Value of the lement (the valid value) |
/// | **description** | | (Optional) Description of the element (valid value) |
class EnumElementDef {

  /// Position of the element within the list of valid values (must be unique, sequential).
  ordinal: Int32

  /// Value of the element (the valid value).
  value: String

  /// (Optional) Description of the element.
  description: String?
}

/// Definition of a complex, embeddable structure that can be used as an attribute.
///
/// | Variable | | Usage |
/// |---|---|---|
/// | **name** | | Unique name of the embeddable type, which should start with `\(t)` |
/// | **description** | | Explanation of the embeddable type |
/// | **[attributeDefs][AttributeDef]** | | List of attributes unique to this embeddable type |
class StructDef extends TypeDef {

  /// Category is set automatically and fixed (should not be changed).
  fixed category = "STRUCT"
}

/// Used to render the appropriately-wrapped output files for typedef management.
local class TypeDefFile {
  entityDefs: Listing<EntityDef>?
  enumDefs: Listing<EnumDef>?
  structDefs: Listing<StructDef>?
  relationshipDefs: Listing<RelationshipDef>?
}

/// Set up multiple outputs for the module, one for each custom type definition.
const function getOutputs(m): Mapping<String, FileOutput> = new Mapping {
  ["\(m.shared.supertypeDefinition.name).json"] = new FileOutput {
    value = new TypeDefFile {
      entityDefs {
        m.shared.supertypeDefinition
      }
      enumDefs = m.shared.enumerations
      structDefs = m.shared.structures
    }
    renderer = new JsonRenderer {}
  }
  when (m.customTypes != null) {
    for (asset in m.customTypes) {
      ["\(m.shared.supertypeDefinition.name)/\(asset.assetDefinition.name).json"] = new FileOutput {
        value = new TypeDefFile {
          entityDefs {
            asset.assetDefinition
          }
          enumDefs = asset.enumerations
          structDefs = asset.structures
          relationshipDefs = asset.relationships
        }
        renderer = new JsonRenderer {}
      }
    }
  }
}

const function getModuleOutput(m): ModuleOutput = new ModuleOutput {
  files = getOutputs(m)
}

/// Set the output of the module to be separate files for each custom type definition in the model.
output = getModuleOutput(this)
