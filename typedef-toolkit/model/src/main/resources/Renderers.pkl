/* SPDX-License-Identifier: Apache-2.0
   Copyright 2024 Atlan Pte. Ltd. */

/// Module for rendering the various portions of front-end code necessary to use the typedef via the UI.
@ModuleInfo { minPklVersion = "0.25.1" }
module com.atlan.typedef.Renderers
import "Model.pkl"

abstract class TypeScriptRenderer extends ValueRenderer {
  model: Model?
  converters: Mapping<Class|String, (unknown) -> Any>

  /// Render the given value as TypeScript code.
  abstract function renderTypeScript(): String

  /// Render the given value as TypeScript code, only if it can be rendered by this renderer;
  /// otherwise throw an error.
  function renderDocument(_) =
    if (model == null)
      throw("""
        Invalid input: model has not been passed through to the renderer.
        """)
    else
      renderTypeScript()
}

/// Renders the TypeScript code for index.ts file
class IndexL3 extends TypeScriptRenderer {
  model = super.model
  fixed supertype = model.shared.supertypeDefinition
  fixed supertypeCamel = supertype.name.decapitalize()
  fixed ui = model.shared.ui

  function renderTypeScript(): String =
    new Listing {
      """
      import \(supertype.name) from '\(ui?.image?.svgUrl)'
      import \(supertype.name)SVG from '\(ui?.image?.svgPath)'
      import { sourceInterface } from '~/types/sourceConfigs/source.interface'
      import { hierarchyFilters } from './hierarchyFilters'
      import { assetTypeList } from './assetTypes'
      import { getAssetTypes } from './getAssetTypes'

      const \(supertypeCamel): sourceInterface = {
          id: '\(supertype.name.toLowerCase())',
          label: '\(supertype.label ?? supertype.name)',
          image: \(supertype.name),
          svg: \(supertype.name)SVG,
          isQueryableSource: \(ui?.isQueryableSource ?? false),
          hierarchyFilters: hierarchyFilters,
          assetTypes: assetTypeList,
          sourceLevelCommonProjections: [],
          getAssetTypes,
      }

      export default \(supertypeCamel)
      """
    }.join("\n")
}

/// Renders the TypeScript code for assetTypes.ts file
class AssetTypes extends TypeScriptRenderer {
  model = super.model
  fixed supertype = model.shared.supertypeDefinition
  fixed assetTypes = model.customEntityDefs

  function renderTypeScript(): String =
    new Listing {
            """
            import { assetTypeInterface } from '~/types/sourceConfigs/assetType.interface'
            """
          for (entityDef in assetTypes) {
            """
            import { \(entityDef.name)MinimalAttributes, \(entityDef.name)AdditionalAttributes } from '../attributes/\(entityDef.name.decapitalize())'
            """
          }
      """

      export const assetTypeList: assetTypeInterface[] = [
      """
          for (idx, assetType in assetTypes) {
            let (children: String = childRelationshipNames(assetType, model.customTypes!!))
            """
                {
                    id: '\(assetType.name)',
                    label: '\(assetType?.label ?? assetType.name)',
                    fullLabel: '\(assetType?.label ?? assetType.name)',
                    image: '\(assetType?.icon.name ?? assetType.name)',
                    source: '\(supertype.name)',
                    categoryType: '\(supertype.name)',
                    relationships: [\(children)],
                    priorityOrder: \(idx + 1),
                    projections: {
                        required: \(assetType.name)MinimalAttributes,
                        additional: \(assetType.name)AdditionalAttributes,
                    },
                },
            """
          }
      """
      ]
      """
        }.join("\n")
}

/// Returns the names of the child relationships from fromAsset to toAsset.
///
/// - toAsset - the asset type that is the child in the relationship
/// - fromAsset - the asset type that is the parent in the relationship
const function childRelationshipNames(fromAsset: Model.EntityDef, customTypes: Mapping<String, Model.CustomAssetType>): String =
  new Listing {
    for (_, type in customTypes) {
      for (relnDef in type.relationships ?? List()) {
        when (relnDef.endDef1.type == fromAsset.name && relnDef.endDef1.isContainer) {
          "'\(relnDef.endDef1.name)'"
        }
        when (relnDef.endDef2.type == fromAsset.name && relnDef.endDef2.isContainer) {
          "'\(relnDef.endDef2.name)'"
        }
      }
    }
  }.join(", ")

/// Renders the TypeScript code for each attributes/..ts file detailing attribute projections
/// for each asset type
class Attributes extends TypeScriptRenderer {
  model = super.model
  assetType: String
  fixed asset: Model.CustomAssetType? = model.customTypes.getOrNull(assetType)
  fixed relationships = model.customRelationshipDefs
  fixed entityDef = new Model.EntityDef {
    name = assetType
    description = asset.description
    superTypes { model.shared.supertypeDefinition.name }
    attributes = asset.attributes
  }
  fixed breadcrumb: Map<String, Model.Breadcrumb> = model.shared.ui.breadcrumb?.toMap() ?? Map()
  fixed bcDepth: Int = breadcrumb.keys.toList().indexOfOrNull(assetType) ?? 0
  fixed bcKeys: List<String> = if (bcDepth > 0) breadcrumb.keys.toList().sublist(0, bcDepth) else List()

  fixed minimalAttributes: Set<String> = new Listing {
    when (asset?.parentQualifiedName != null) {
        asset.parentQualifiedName
    }
    for (attributeDef: Model.AttributeDef in entityDef.attributeDefs ?? List()) {
      when (attributeDef.childCount) {
          attributeDef.name
      }
      // Include breadcrumb attributes
      for (typeName in bcKeys) {
        let (bcDetails = breadcrumb.getOrNull(typeName)) bcDetails?.q
        let (bcDetails = breadcrumb.getOrNull(typeName)) bcDetails?.n
      }
    }
  }.toSet()

  function renderTypeScript(): String =
    new Listing {
        """
        import {
            EntityAttributeKeyFomTypeName,
            IndexSearchResponseEntity,
            RelationEntityAttributeKeyFomTypeName,
        } from '~/api/metastore/types'
        import { AssetRelationAttributes } from '~/utils/metastore/asset'

        // attributes for asset cards, preview
        export const \(entityDef.name)MinimalAttributes = [
        """
      for (attr in minimalAttributes) {
          """
              '\(attr)',
          """
      }
        """
        ] as const satisfies ReadonlyArray<EntityAttributeKeyFomTypeName<'\(entityDef.name)'>>

        // additional attributes, for asset profile
        export const \(entityDef.name)AdditionalAttributes = [
        """
      for (attributeDef: Model.AttributeDef in entityDef.attributeDefs ?? List()) {
        when (attributeDef.label != null && !minimalAttributes.contains(attributeDef.name)) {
          // Include any other attributes with labels as additional
            """
                '\(attributeDef.name)',
            """
        }
      }
      // Also include any relationship attributes referring to parents (for ParentAssetDrawer)
      for (relationship: Model.RelationshipDef in relationships) {
        when (relationship.endDef1.type == assetType && relationship.endDef2.isContainer) {
            """
                '\(relationship.endDef1.name)',
            """
        }
        when (relationship.endDef2.type == assetType && relationship.endDef1.isContainer) {
            """
                '\(relationship.endDef2.name)',
            """
        }
      }
        """
        ] as const satisfies ReadonlyArray<
            EntityAttributeKeyFomTypeName<'\(entityDef.name)'>
        >

        // combined attributes
        export const \(entityDef.name)Attributes = [
            ...\(entityDef.name)MinimalAttributes,
            ...\(entityDef.name)AdditionalAttributes,
        ] as const satisfies ReadonlyArray<EntityAttributeKeyFomTypeName<'\(entityDef.name)'>>

        // relation attributes
        export const \(entityDef.name)RelationAttributes = [
            ...AssetRelationAttributes,
        ] as const satisfies ReadonlyArray<
            RelationEntityAttributeKeyFomTypeName<'\(entityDef.name)'>
        >

        // types
        export type \(entityDef.name)Entity<IncludeAdditionalAttributes extends boolean = false> =
            IncludeAdditionalAttributes extends true
                ? IndexSearchResponseEntity<
                    '\(entityDef.name)',
                    (typeof \(entityDef.name)Attributes)[number],
                    (typeof \(entityDef.name)RelationAttributes)[number]
                  >
                : IndexSearchResponseEntity<
                    '\(entityDef.name)',
                    (typeof \(entityDef.name)MinimalAttributes)[number],
                    (typeof \(entityDef.name)RelationAttributes)[number]
                  >
        """
    }.join("\n")

}

/// Renders the TypeScript code snippet for useBody.ts file to cover parent-child navigation
class UseBody extends TypeScriptRenderer {
  model = super.model
  fixed customTypes = model.customTypes

  function renderTypeScript(): String =
    new Listing {
        """
        ...
        export function applyFilters({
            facets,
            base,
            connectorName,
            state,
        }: {
            facets: Record<string, any>
            base: Bodybuilder
            connectorName?: string
            state: Ref<string>
        }) {
            const authStore = useAuthStore()

            // filters
            Object.keys(facets ?? {})?.forEach((mkey) => {
                const filterObject = facets[mkey]
                switch (mkey) {
                    ...
                    // *** COPY / PASTE START ***
        """
      for (_, type: Model.CustomAssetType in customTypes) {
        when (type.parentQualifiedName != null) {
            """
                        case '\(type.parentQualifiedName)':
            """
        }
      }
        """
                    // *** END COPY / PASTE ***
                    case 'cubeQualifiedName':
                    case 'cubeDimensionQualifiedName':
                    case 'cubeParentFieldQualifiedName':
                    case 'cubeHierarchyQualifiedName': {
                        if (filterObject) {
                            base.filter('term', mkey, filterObject)
                        }
                        break
                    }
                    ...
                }
            })
        }
        """
    }.join("\n")

}

/// Renders the TypeScript code snippet for projection.ts file referencing the attribute projections
class Projection extends TypeScriptRenderer {
  model = super.model
  assetType: String
  fixed customTypes = model.customTypes

  function renderTypeScript(): String =
    new Listing {
      """
      import { PolicyAttributes } from '~/constant/_projection'
      import {
          CalculationViewMinimalAttributes,
          CalculationViewAdditionalAttributes,
      } from '~/constant/source/sql/common/attributes/calculationView'
      ...
      // *** COPY / PASTE START ***
      """
      for (typeName, _ in customTypes) {
        """
        import { \(typeName)Attributes } from '~/constant/source/\(model.shared.supertypeDefinition.name.decapitalize())/attributes/\(typeName.decapitalize())'
        """
      }
        """
        // *** END COPY / PASTE ***

        ...

        export const AssetAttributes = [
        // *** COPY / PASTE START ***
        """
      for (typeName, _ in customTypes) {
          """
              ...\(typeName)Attributes,
          """
      }
        """
        // *** END COPY / PASTE ***
        ]
        """
    }.join("\n")

}

/// Renders the TypeScript code for methods.ts file.
class Methods extends TypeScriptRenderer {
  model = super.model
  fixed typeNames: List<String> = model.customEntityDefs.fold(List(), (acc: List<String>, entityDef) -> acc.add("'\(entityDef.name)'"))
  fixed superTypeName: String = model.shared.supertypeDefinition.name

  function renderTypeScript(): String =
    new Listing {
        """
        import {
            IndexSearchResponseEntity,
            GetChildrenEntityNameIncludingSelf,
        } from '~/api/metastore/types'

        export default function use\(superTypeName)Info<
            T extends IndexSearchResponseEntity = IndexSearchResponseEntity,
        >() {
        """
      for (_, details in model.shared.ui?.breadcrumb ?? Map()) {
          """
              const \(details.q) = (asset: T) => asset?.attributes?.\(details.q) ?? ''
              const \(details.n) = (asset: T) => asset?.attributes?.\(details.n) ?? ''
          """
      }
        """

            function is\(superTypeName)Asset(
                asset?: IndexSearchResponseEntity<
                    GetChildrenEntityNameIncludingSelf<'Asset'>
                >
            ): asset is IndexSearchResponseEntity<
                \(typeNames.join(" | "))
            > {
                return (
        """
      new Listing {
        for (typeName in typeNames) {
            """
                        asset?.typeName === \(typeName)
            """
        }
      }.join(" ||\n")
        """
                )
            }

            return {
        """
      for (_, details in model.shared.ui?.breadcrumb ?? Map()) {
          """
                  \(details.q),
                  \(details.n),
          """
      }
        """
                is\(superTypeName)Asset,
            }
        }
        """
    }.join("\n")
}

/// Renders the TypeScript code for the getAssetTypes.ts file.
class GetAssetTypes extends TypeScriptRenderer {
  model = super.model

  fixed assetTypes = model.customEntityDefs
  fixed relationships = model.customRelationshipDefs

  function renderTypeScript(): String =
    new Listing {
        """
        import { GetAssetTypes } from '~/types/sourceConfigs/source.interface'
        import { getVisibleItems } from '~/utils/getVisibleItems'
        import { DisplayPreference } from '~/constant/displayProperties'
        import {
            getOverviewTab,
            getLineageTab,
            getRelatedAssetsTab,
            getPreviewActivityTab,
            getPreviewLineageTab,
            getPreviewOverviewTab,
            getPreviewPropertiesTab,
            getPreviewRelationsTab,
            getPreviewRequestsTab,
            getPreviewResourcesTab,
        } from '~/constant/source/utils'
        import { AtomicBlocks, CompositeBlocks, SummaryBlocks } from '@/source'
        """
      for (assetType, _ in model.customTypes ?? Map()) {
          """
          import {
              \(assetType)MinimalAttributes,
              \(assetType)AdditionalAttributes,
          } from '../attributes/\(assetType.decapitalize())'
          """
      }
        """

        export const getAssetTypes: GetAssetTypes = ({
            displayPreferences,
            hideStar,
            searchQueries,
            isCompact,
            t,
        }) => [
        """
      for (idx, assetType: Model.EntityDef in assetTypes) {
        let (type: Model.CustomAssetType = model.customTypes?.getOrNull(assetType.name)!!)
        """
            {
                id: '\(assetType.name)',
                label: t('\(type.label)'),
                fullLabel: t('\(type.label)'),
                image: '\(type.icon.name)',
                categoryType: '\(model.shared.supertypeDefinition.name)',
                relationships: [
        """
        for (relationship: Model.RelationshipDef in relationships) {
          when (relationship.endDef1.type == assetType.name && relationship.endDef1.isContainer) {
            """
                        '\(relationship.endDef1.name)',
            """
          }
          when (relationship.endDef2.type == assetType.name && relationship.endDef2.isContainer) {
              """
                          '\(relationship.endDef2.name)',
              """
          }
        }
        """
                ],
                projections: {
                    required: \(assetType.name)MinimalAttributes,
                    additional: \(assetType.name)AdditionalAttributes,
                },
                priorityOrder: \(idx + 1),
                discovery: {
                    assetCard: {
                        header: {
                            blocks: [
                                {
                                    component: CompositeBlocks.Row,
                                    children: getVisibleItems([
                                        {
                                            component: AtomicBlocks.Profiling,
                                            visible: !isCompact,
                                        },
                                        {
                                            component: AtomicBlocks.AnnouncementPopover,
                                        },
                                        {
                                            component: AtomicBlocks.LineageLink,
                                        },
                                        {
                                            component: AtomicBlocks.StarredByMe,
                                            hideStar,
                                            visible: !hideStar,
                                        },
                                    ]),
                                    emits: [],
                                    props: {
                                        attrsToBindForComponent: {
                                            class: 'flex items-center pl-3 ml-auto gap-x-1',
                                        },
                                    },
                                },
                            ],
                        },
                        body: {
                            blocks: [
                                {
                                    component: AtomicBlocks.AssetDescription,
                                    searchQueries,
                                    visible: displayPreferences.includes(
                                        DisplayPreference.DESCRIPTION
                                    ),
                                },
                            ],
                        },
                        footer: {
                            blocks: [
                                { component: AtomicBlocks.LastEditedOrCreated },
        """
        for (attr in assetType.attributeDefs) {
          when (attr.childCount) {
            """
                                    {
                                        component: AtomicBlocks.ItemsCount,
                                        countAttributePath: 'attributes.\(attr.name)',
                                        singularLabel: t('\(attr.label)'),
                                        pluralLabel: t('\(attr.labelPlural)'),
                                    },
            """
          }
        }
        """
                            ],
                        },
                    },
                    filters: [], // TODO: asset type-specific filters
                    profile: {
                        tabs: [
                            getOverviewTab({
                                t,
                                summary: {
                                    blocks: [
        """
        for (relationship: Model.RelationshipDef in relationships) {
          when (relationship.endDef1.type == assetType.name && relationship.endDef2.isContainer) {
            let (relatedType: Model.CustomAssetType = model.customTypes.getOrNull(relationship.endDef2.type)!!)
              """
                                              {
                                                  component: SummaryBlocks.ParentAssetDrawer,
                                                  label: t('\(relatedType.label)'),
                                                  parentAssetPath: 'attributes.\(relationship.endDef1.name)',
                                              },
              """
          }
          when (relationship.endDef2.type == assetType.name && relationship.endDef1.isContainer) {
            let (relatedType: Model.CustomAssetType = model.customTypes.getOrNull(relationship.endDef1.type)!!)
              """
                                              {
                                                  component: SummaryBlocks.ParentAssetDrawer,
                                                  label: t('\(relatedType.label)'),
                                                  parentAssetPath: 'attributes.\(relationship.endDef2.name)',
                                              },
              """
          }
        }
        for (attr in assetType.attributeDefs) {
          when (attr.childCount) {
              """
                                              {
                                                  component: SummaryBlocks.KeyValue,
                                                  key: t('\(attr.labelPlural.capitalize())'),
                                                  value: 'attributes.\(attr.name)',
                                                  isCount: true,
                                              },
              """
          }
        }
        """
                                        {
                                            component: SummaryBlocks.ConnectionDrawer,
                                        },
                                    ],
                                    showAIDescription: true,
                                },
                            }),
        """
        for (relationship: Model.RelationshipDef in relationships) {
          when (relationship.endDef1.type == assetType.name && relationship.endDef1.isContainer && model.customTypes.getOrNull(relationship.endDef2.type) != null) {
            let (relatedType: Model.CustomAssetType = model.customTypes.getOrNull(relationship.endDef2.type)!!)
              """
                                  {
                                      ...getRelatedAssetsTab({
                                          t,
                                          additional: {
                                              facets: ({ asset }) => ({
                                                  typeNames: ['\(relationship.endDef2.type)'],
                                                  \(relatedType.parentQualifiedName):
                                                      asset.attributes.qualifiedName,
                                              }),
                                          },
                                      }),
                                      label: t('\(relatedType.labelPlural)'),
                                      tooltip: t('\(relatedType.labelPlural)'),
                                      scrubbed: false,
                                  },
              """
          }
          when (relationship.endDef2.type == assetType.name && relationship.endDef2.isContainer && model.customTypes.getOrNull(relationship.endDef1.type) != null) {
            let (relatedType: Model.CustomAssetType = model.customTypes.getOrNull(relationship.endDef1.type)!!)
              """
                                  {
                                      ...getRelatedAssetsTab({
                                          t,
                                          additional: {
                                              facets: ({ asset }) => ({
                                                  typeNames: ['\(relationship.endDef1.type)'],
                                                  \(relatedType.parentQualifiedName):
                                                      asset.attributes.qualifiedName,
                                              }),
                                          },
                                      }),
                                      label: t('\(relatedType.labelPlural)'),
                                      tooltip: t('\(relatedType.labelPlural)'),
                                      scrubbed: false,
                                  },
              """
          }
        }
        """
                        ],
                    },
                    preview: {
                        tabs: [
                            getPreviewOverviewTab({
                                t,
                                blocks: [
        """
        for (attr in assetType.attributeDefs) {
          when (attr.childCount) {
              """
                                          {
                                              component: AtomicBlocks.TabSwitcherTextBlock,
                                              text: 'attributes.\(attr.name)',
                                              label: t('\(attr.labelPlural.capitalize())'),
                                              tabName: 'Relations',
                                          },
              """
          }
        }
        """
                                ],
                            }),
        """
        for (relationship: Model.RelationshipDef in relationships) {
          when (relationship.endDef1.type == assetType.name && relationship.endDef1.isContainer && model.customTypes.getOrNull(relationship.endDef2.type) != null) {
            let (relatedType: Model.CustomAssetType = model.customTypes.getOrNull(relationship.endDef2.type)!!)
              """
                                  {
                                      ...getPreviewRelationsTab({
                                          t,
                                          additional: {
                                              facets: ({ asset }) => ({
                                                  typeNames: ['\(relationship.endDef2.type)'],
                                                  \(relatedType.parentQualifiedName):
                                                      asset.attributes.qualifiedName,
                                              }),
                                          },
                                      }),
                                      label: t('\(relatedType.labelPlural)'),
                                      icon: '\(relatedType.icon.name)',
                                      activeIcon: '\(relatedType.icon.nameActive)',
                                  },
              """
          }
          when (relationship.endDef2.type == assetType.name && relationship.endDef2.isContainer && model.customTypes.getOrNull(relationship.endDef1.type) != null) {
            let (relatedType: Model.CustomAssetType = model.customTypes.getOrNull(relationship.endDef1.type)!!)
              """
                                  {
                                      ...getPreviewRelationsTab({
                                          t,
                                          additional: {
                                              facets: ({ asset }) => ({
                                                  typeNames: ['\(relationship.endDef1.type)'],
                                                  \(relatedType.parentQualifiedName):
                                                      asset.attributes.qualifiedName,
                                              }),
                                          },
                                      }),
                                      label: t('\(relatedType.labelPlural)'),
                                      icon: '\(relatedType.icon.name)',
                                      activeIcon: '\(relatedType.icon.nameActive)',
                                  },
              """
          }
        }
        """
                            getPreviewLineageTab({ t }),
                            getPreviewActivityTab({ t }),
                            getPreviewResourcesTab({ t }),
                            getPreviewRequestsTab({ t }),
                            getPreviewPropertiesTab({
                                t,
                                blocks: [
                                    { component: AtomicBlocks.SourceUpdated },
                                    { component: AtomicBlocks.SourceCreated },
                                    { component: SummaryBlocks.ConnectionDrawer },
                                    {
                                        component: AtomicBlocks.CopyAttribute,
                                        attributePath: 'guid',
                                        label: t('Unique identifier'),
                                        successMessage: t('Identifier copied!'),
                                    },
                                    {
                                        component: AtomicBlocks.CopyAttribute,
                                        attributePath: 'attributes.qualifiedName',
                                        label: t('Qualified name'),
                                        successMessage: t('Qualified name copied'),
                                    },
                                    { component: AtomicBlocks.Divider },
                                    { component: AtomicBlocks.LastUpdatedByInAtlan },
                                    { component: AtomicBlocks.LastUpdatedInAtlan },
                                    { component: AtomicBlocks.LastSyncedInAtlan },
                                    { component: AtomicBlocks.CreatedInAtlan },
                                    { component: AtomicBlocks.CreatedByInAtlan },
                                ],
                            }),
                        ],
                    },
                },
            },
        """
      }
        """
        ]
        """
    }.join("\n")

}

/// Renders the TypeScript code for the hierarchyFilters.ts file.
class HierarchyFilters extends TypeScriptRenderer {
  model = super.model

  function renderTypeScript(): String =
    new Listing {
        """
        import { hierarchyFiltersInterface } from '~/types/sourceConfigs/hierarchyFilters.interface'

        export const hierarchyFilters: hierarchyFiltersInterface[] = [
        """
      for (filter in model.shared.ui?.hierarchyFilters ?? List()) {
        let (type: Model.CustomAssetType = model.customTypes.getOrNull(filter.typeName)!!)
          """
              {
                  typeName: '\(filter.typeName)',
                  name: '\(type.label)',
                  parent: '\(filter.parent)',
                  attribute: '\(filter.attribute)',
                  level: \(filter.level),
                  image: '\(type.icon.name)',
              },
          """
      }
        """
        ]
        """
    }.join("\n")

}

/// Renders the TypeScript code for the index.ts file at the root of the super-type-specific UI area.
class IndexL2 extends TypeScriptRenderer {
  model = super.model

  function renderTypeScript(): String =
    new Listing {
        """
        export * as \(model.shared.supertypeDefinition.name.decapitalize()) from './common'
        """
    }.join("\n")
}

/// Renders the TypeScript snippet for the index.ts file at the root of the entire source-config UI area.
class IndexL1 extends TypeScriptRenderer {
  model = super.model

  function renderTypeScript(): String =
    new Listing {
        """
        // *** COPY / PASTE START ***
        import * as \(model.shared.supertypeDefinition.name.decapitalize()) from './\(model.shared.supertypeDefinition.name.decapitalize())'
        // *** END COPY / PASTE ***

        import { assetTypeList as atlanNativeAssetTypes } from './atlanNative/assetTypes'
        import { assetTypeInterface } from '~/types/sourceConfigs/assetType.interface'
        import { TAGS_ASSET_TYPENAMES } from '~/constant/governance/classification'

        // Utils
        import { autoIncrementGroupOrder } from '~/utils/sourceConfig/groupOrder'
        import { getAssetTypes } from './bi/preset/getAssetTypes'
        // An array of all sources, including SQL, BI, SaaS, objectStore, API, ELT, and eventStore.
        export const SourceList = [
            ...Object.values(queryableSql).map((component) => component.default),
            ...Object.values(nonQueryableSql).map((component) => component.default),
        ...
        // *** COPY / PASTE START ***
            ...Object.values(\(model.shared.supertypeDefinition.name.decapitalize())).map((component) => component.default),
        // *** END COPY / PASTE ***
            api.default,
        ]

        ...

        export const SuperTypeNameEnum = {
            SQL: 'SQL',
            BI: 'BI',
            SaaS: 'SaaS',
        ...
        // *** COPY / PASTE START ***
            \(model.shared.supertypeDefinition.name): '\(model.shared.supertypeDefinition.name)',
        // *** END COPY / PASTE ***
        }
        """
    }.join("\n")
}

/// Renders the JSON snippet for en.json English-language localizations.
class Localizations extends TypeScriptRenderer {
  model = super.model

  // TODO: any others once we've implemented further extensibility
  fixed labels: Set<String> = new Listing {
    for (entityDef: Model.EntityDef in model.customEntityDefs ?? List()) {
      when (entityDef.label != null) { entityDef.label }
      when (entityDef.labelPlural != null) { entityDef.labelPlural }
      for (attrDef: Model.AttributeDef in entityDef.attributeDefs) {
        when (attrDef.label != null) { attrDef.label }
        when (attrDef.labelPlural != null) { attrDef.labelPlural }
      }
    }
  }.toSet()

  function renderTypeScript(): String =
    new Listing {
      for (label in labels) {
        """
        "\(label)": "\(label)"
        """
      }
    }.join("\n")
}

/// Renders the TypeScript snippet for iconMap.ts to include any custom icons.
class IconMap extends TypeScriptRenderer {
  model = super.model

  function renderTypeScript(): String =
    new Listing {
      """
      import { defineAsyncComponent } from 'vue'

      // source list
      import Snowflake from '~/assets/images/source/svg/Snowflake.svg'
      ...
      // *** COPY / PASTE START ***
      """
      for (_, details: Model.CustomAssetType in model.customTypes ?? Map()) {
          """
          import \(details.icon.name) from '\(details.icon.path)',
          """
        when (details.icon.activeVariant) {
            """
            import \(details.icon.nameActive) from '\(details.icon.pathActive)',
            """
        }
      }
      """
      // *** END COPY / PASTE ***
      // Don't remove below comment used by plop
      // INSERT NEW ICON IMPORT HERE
      import Rule from '~/assets/images/icons/rule.svg'
      ...

      export default {
          // Don't remove below comment used by plop
          // INSERT RETURN HERE
          ...
          // *** COPY / PASTE START ***
      """
      for (_, details: Model.CustomAssetType in model.customTypes ?? Map()) {
        """
            \(details.icon.name),
        """
        when (details.icon.activeVariant) {
            """
                \(details.icon.nameActive),
            """
        }
      }
      """
          // *** END COPY / PASTE ***
          ...
      }
      """
    }.join("\n")
}

/// Renders the Vue code for parentAssetInline.vue to include any breadcrumbs for parent paths.
class ParentAssetInline extends TypeScriptRenderer {
  model = super.model
  fixed superTypeName: String = model.shared.supertypeDefinition.name

  function renderTypeScript(): String =
    new Listing {
      """
      <template>
          <div class="flex items-center gap-x-1.5 gap-y-1">
              <!-- connector name -->
              <AssetItemFilterTooltip
                  v-if="
                      connectionName(asset) &&
                      preference?.display?.includes('connection')
                  "
                  type="Connection"
                  icon="Connection"
                  :title="connectionName(asset)"
                  :hideSearch="page !== 'assets'"
                  :showDrawerIcon="page !== 'assets'"
                  :isButtonHidden="isAssetPartial"
                  :showCaret="false"
                  @guidToFetch="
                      handleOpenDrawer(
                          'connectionQualifiedName',
                          connectionQualifiedName(asset)
                      )
                  "
              />
              <!-- *** COPY / PASTE START *** -->
      """
      for (typeName, details in model.shared.ui?.breadcrumb ?? Map()) {
        let (type = model.customTypes?.getOrNull(typeName)!!)
          """
                  <AssetItemFilterTooltip
                      v-if="is\(superTypeName)Asset(asset) && \(details.n)(asset) && !isCompact"
                      type="\(typeName)"
                      icon="\(type.icon.name)"
                      :title="\(details.n)(asset)"
                      :hideSearch="page !== 'assets'"
                      :showDrawerIcon="page !== 'assets'"
                      :isButtonHidden="isAssetPartial"
                      :showCaret="
                          !page.startsWith('excel') && !page.startsWith('gsheets')
                      "
                      @guidToFetch="
                          handleOpenDrawer('\(details.q)', \(details.q)(asset))
                      "
                  />
          """
      }
      """
              <!-- *** END COPY / PASTE *** -->
          </div>
      </template>

      <script lang="ts">
          import { computed, defineComponent, PropType, toRefs } from 'vue'
          import { useI18n } from 'vue-i18n'
          import { Tooltip as AntTooltip } from 'ant-design-vue'

          // Composables
          import useAssetInfo from '~/composables/discovery/useAssetInfo'
          import { getPluralString } from '~/utils/number'
          <!-- *** COPY / PASTE START *** -->
          import use\(superTypeName)Info from '~/constant/source/\(superTypeName.decapitalize())/methods'
          <!-- *** END COPY / PASTE *** -->

          // Types
          import { assetInterface } from '~/types/assets/asset.interface'

          // Components
          import AssetItemFilterTooltip from '~/components/common/assets/misc/assetItemFilterTooltip.vue'
          import AtlanIcon from '@/common/icon/atlanIcon.vue'

          export default defineComponent({
              components: { AssetItemFilterTooltip, AtlanIcon, AntTooltip },
              props: {
                  asset: {
                      type: Object as PropType<assetInterface>,
                      required: true,
                  },
                  preference: {
                      type: Object,
                      required: false,
                      default() {
                          return {}
                      },
                  },
                  page: {
                      type: String,
                      required: false,
                      default: 'notAssets',
                  },
                  isCompact: {
                      type: Boolean,
                      default: false,
                      required: false,
                  },
              },
              emits: ['guidToFetch', 'handleBrowseAsset', 'qfToFetch'],
              setup(props, { emit }) {
                  const { t } = useI18n()
                  const {
                      ...
                  } = useAssetInfo()
                  <!-- *** COPY / PASTE START *** -->
                  const {
      """
      for (_, details in model.shared.ui?.breadcrumb ?? Map()) {
          """
                          \(details.q),
                          \(details.n),
          """
      }
      """
                      is\(superTypeName)Asset,
                  } = use\(superTypeName)Info()
                  <!-- *** END COPY / PASTE *** -->

                  const { page } = toRefs(props)

                  // Computed Methods
                  ...

                  return {
                      ...
                      t,
                      <!-- *** COPY / PASTE START *** -->
      """
      for (_, details in model.shared.ui?.breadcrumb ?? Map()) {
          """
                          \(details.q),
                          \(details.n),
          """
      }
      """
                      is\(superTypeName)Asset,
                      <!-- *** END COPY / PASTE *** -->
                  }
              },
          })
      </script>
      """
    }.join("\n")
}
