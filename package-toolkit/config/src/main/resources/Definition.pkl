/* SPDX-License-Identifier: Apache-2.0
   Copyright 2024 Atlan Pte. Ltd. */

/// Template for defining configuration for a custom package in Atlan.
///
/// | Variable | | Usage | Default |
/// |---|---|---|---|
/// | **packageId** | | Unique identifier for the package, including its namespace. | |
/// | **packageName** | | Display name for the package, as it should be shown in the UI. | |
/// | **version** | | Version of this package, following semantic versioning. | |
/// | **description** | | Description for the package, as it should be shown in the UI. | |
/// | **iconUrl** | | Link to an icon to use for the package, as it should be shown in the UI. | |
/// | **docsUrl** | | Link to an online document describing the package. | |
/// | **uiConfig** | | Configuration for the UI of the custom package. | |
/// | **implementationLanguage** | | Coding language the package is implemented in. | |
/// | **process** | | Details of the container image and command within it to actually do the processing of the custom package. | |
/// | inputs | | (Optional) Any inputs the custom package expects to perform its logic. | |
/// | outputs | | (Optional) Any outputs that the custom package logic is expected to produce. | |
/// | keywords | | (Optional) Any keyword labels to apply to the package. | |
/// | allowSchedule | | (Optional) Whether to allow the package to be scheduled (true) or only run immediately (false). | `true` |
/// | certified | | (Optional) Whether the package should be listed as certified (true) or not (false). | `true` |
/// | preview | | (Optional) Whether the package should be labeled as an early preview in the UI (true) or not (false). | `false` |
/// | connectorType | | (Optional) If the package needs to configure a connector, specify its type here. | |
/// | category | | Name of the pill under which the package should be categorized in the marketplace in the UI. | `custom` |
@ModuleInfo { minPklVersion = "0.25.1" }
open module com.atlan.pkg.Definition

extends "Task.pkl"
import "pkl:semver"
import "Connectors.pkl"
import "UI.pkl"
import "Orchestrate.pkl"
import "Render.pkl"

/// Unique identifier for the package, including its namespace.
/// For example: @csa/open-api-spec-loader
packageId: String(matches(Regex("@[a-z0-9-]+/[a-z0-9-]+")))

/// Display name for the package, as it should be shown in the UI.
packageName: String

/// Version of this package, following semantic versioning.
version: semver.Version

/// Description for the package, as it should be shown in the UI.
description: String

/// Link to an icon to use for the package, as it should be shown in the UI.
iconUrl: String

/// Link to an online document describing the package.
docsUrl: String

/// Configuration for the UI of the custom package.
/// Generally you can manage this in a separate file that amends the UI template, and then import it
/// using `import("ui.pkl")`.
uiConfig: UI

/// Configuration for the flow of the custom package.
/// Generally you can manage this in a separate file that amends the Flow template, and then import it
/// using `import("flow.pkl")`.
flow: Orchestrate?

/// Coding language the package is implemented in.
/// This will control what (if any) strongly-typed configuration hand-over classes are generated by the toolkit.
/// (Note: if using 'Other', no strongly-typed configuration hand-over classes will be generated.)
implementationLanguage: CodeLanguage

/// (Optional) Any keyword labels to apply to the package.
keywords: Listing<String> = new Listing {}

/// (Optional) Whether to allow the package to be scheduled (default, true) or only run immediately (false).
allowSchedule: Boolean = true

/// (Optional) Whether the package should be listed as certified (default, true) or not (false).
certified: Boolean = true

/// (Optional) Whether the package should be labeled as an early preview in the UI (true) or not (default, false).
preview: Boolean = false

/// (Optional) If the package needs to configure a connector, specify its type here.
connectorType: Connectors.Type?

/// Name of the pill under which the package should be categorized in the marketplace in the UI.
category: String = "custom"

// --- CONTENT ABOVE THIS LINE IS INTENDED INPUT ---
// --- CONTENT BELOW THIS LINE IS USED TO GENERATE OUTPUTS ---

fixed calculatedInputs: Map<String, String> = new Mapping {
  ...calculateInputs(inputs)
  for (n: String, u: UI.UIElement in uiConfig.properties) {
    when (u is UI.FileUploader || u is UI.FileCopier) {
      [n] = "/tmp/inputs/\(n).txt"
    }
  }
}.toMap()

/// Coding languages the toolkit can generate strongly-typed configuration hand-over classes for.
typealias CodeLanguage = "Java"|"Kotlin"|"Python"|"Other"

/// (Generated) Unique name to use for file-based objects for the package.
hidden fixed imageName = packageId.replaceAll("@", "").replaceAll("/", "-")

const function getPythonPkgName(m): String = getLowerSnakeCase(getPascalCase(m.packageName))

/// Set up multiple outputs for the module, one for each configuration file.
/// - `m` the package config to generate outputs for
const function getOutputs(m): Mapping<String, FileOutput> = new Mapping {
  ["build/package/\(m.imageName)/configmaps/default.yaml"] = Render.getConfigMap(m)
  ["build/package/\(m.imageName)/templates/default.yaml"] = Render.getWorkflowTemplate(m)
  ["build/package/\(m.imageName)/index.js"] = Render.getIndexJs()
  ["build/package/\(m.imageName)/package.json"] = Render.getPackageJson(m)
  when (m.implementationLanguage == "Kotlin" || m.implementationLanguage == "Java") {
    ["src/main/kotlin/\(getClassName(m.packageName)).kt"] = Render.getConfigClassKt(m, getClassName(m.packageName))
  }
  when (m.implementationLanguage == "Python") {
    ["\(getPythonPkgName(m))/\(getPythonPkgName(m))_cfg.py"] = Render.getConfigClassPy(m)
    ["\(getPythonPkgName(m))/__init__.py"] = Render.getBlankFile()
    ["\(getPythonPkgName(m))/main.py.example"] = Render.getMainPy(getPythonPkgName(m))
    ["\(getPythonPkgName(m))/logging.conf"] = Render.getLoggingConfPy()
    ["requirements.txt"] = Render.getRequirementsPy()
    ["requirements-dev.txt"] = Render.getRequirementsDevPy()
    ["version.txt"] = Render.getVersionPy(m)
    ["Dockerfile"] = Render.getDockerfilePy(getPythonPkgName(m))
  }
}

/// Translate the model content into a set of files for both type definitions (JSON)
/// and UI configuration (TypeScript).
const function getModuleOutput(m): ModuleOutput = new ModuleOutput {
  files = getOutputs(m)
}

/// Set the output of the module to be separate files for each custom type definition in the model.
output = getModuleOutput(this)

/// Turn the provided name into a PascalCase name.
const function getPascalCase(name: String): String =
  name.split(Regex("[\\W_]+")).map((word) -> word.capitalize()).join("")

/// Turn the provided name into a lower_snake_case_name.
const function getLowerSnakeCase(text: String): String = getSnakeCase(text).toLowerCase()
local const function getSnakeCase(text: String): String =
  text.replaceAll("_", "").replaceAll(Regex("([A-Z]+)([A-Z][a-z])"), "$1_$2").replaceAll(Regex("([a-z])([A-Z])"), "$1_$2")

const function getClassName(name: String): String = "\(getPascalCase(name))Cfg"
