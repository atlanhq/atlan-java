/* SPDX-License-Identifier: Apache-2.0
   Copyright 2024 Atlan Pte. Ltd. */

/// Template for defining configuration for a custom package in Atlan.
///
/// | Variable | | Usage | Default |
/// |---|---|---|---|
/// | **packageId** | | Unique identifier for the package, including its namespace. | |
/// | **packageName** | | Display name for the package, as it should be shown in the UI. | |
/// | **version** | | Version of this package, following semantic versioning. | |
/// | **description** | | Description for the package, as it should be shown in the UI. | |
/// | **iconUrl** | | Link to an icon to use for the package, as it should be shown in the UI. | |
/// | **docsUrl** | | Link to an online document describing the package. | |
/// | **uiConfig** | | Configuration for the UI of the custom package. | |
/// | **implementationLanguage** | | Coding language the package is implemented in. | |
/// | **containerImage** | | Container image to run the logic of the custom package. | |
/// | **containerCommand** | | Full command to run in the container image, as a list rather than spaced. | |
/// | containerImagePullPolicy | | (Optional) Override the default IfNotPresent policy. | `IfNotPresent` |
/// | outputs | | (Optional) Any outputs that the custom package logic is expected to produce. | |
/// | keywords | | (Optional) Any keyword labels to apply to the package. | |
/// | allowSchedule | | (Optional) Whether to allow the package to be scheduled (true) or only run immediately (false). | `true` |
/// | certified | | (Optional) Whether the package should be listed as certified (true) or not (false). | `true` |
/// | preview | | (Optional) Whether the package should be labeled as an early preview in the UI (true) or not (false). | `false` |
/// | connectorType | | (Optional) If the package needs to configure a connector, specify its type here. | |
/// | category | | Name of the pill under which the package should be categorized in the marketplace in the UI. | `custom` |
@ModuleInfo { minPklVersion = "0.27.2" }
open module com.atlan.pkg.Framework

import "pkl:semver"
import "FrameworkRenderer.pkl"
import "Connectors.pkl"

/// Unique identifier for the package, including its namespace.
/// For example: @csa/open-api-spec-loader
packageId: String(matches(Regex("@[a-z0-9-]+/[a-z0-9-]+")))

/// Display name for the package, as it should be shown in the UI.
packageName: String

/// Version of this package, following semantic versioning.
version: semver.Version

/// Description for the package, as it should be shown in the UI.
description: String

/// Link to an icon to use for the package, as it should be shown in the UI.
iconUrl: String

/// Link to an online document describing the package.
docsUrl: String

/// Configuration for an independent publish step.
/// This is necessary for any package intended to run in a secure mode, where the extraction can
/// run outside the Atlan tenant and the results be transferred (pushed) to the Atlan tenant to be
/// loaded.
publishConfig: PublishConfig?

/// Configuration for the UI of the custom package.
///
/// | Variable | | Usage |
/// |---|---|---|
/// | **[tasks][UIStep]** | | Mapping of top-level tasks to be configured, keyed by the name of the task as it should appear in the UI. |
/// | **[rules][UIRule]** | | Listing of rules to control which inputs appear based on values selected in other inputs. |
uiConfig: UIConfig

/// Coding language the package is implemented in.
/// This will control what (if any) strongly-typed configuration hand-over classes are generated by the toolkit.
/// (Note: if using 'Other', no strongly-typed configuration hand-over classes will be generated.)
implementationLanguage: CodeLanguage

/// Container image to run the logic of the custom package.
containerImage: String

/// Full command to run in the container image, as a list rather than spaced.
containerCommand: Listing<String>

/// (Optional) Override the default IfNotPresent policy.
containerImagePullPolicy: ImagePullPolicy = "IfNotPresent"

/// (Optional) Any outputs that the custom package logic is expected to produce.
outputs: WorkflowOutputs?

/// (Optional) Any keyword labels to apply to the package.
keywords: Listing<String> = new Listing {}

/// (Optional) Whether to allow the package to be scheduled (default, true) or only run immediately (false).
allowSchedule: Boolean = true

/// (Optional) Whether the package should be listed as certified (default, true) or not (false).
certified: Boolean = true

/// (Optional) Whether the package should be labeled as an early preview in the UI (true) or not (default, false).
preview: Boolean = false

/// (Optional) If the package needs to configure a connector, specify its type here.
connectorType: Connectors.Type?

/// Name of the pill under which the package should be categorized in the marketplace in the UI.
category: String = "custom"

// --- CONTENT ABOVE THIS LINE IS INTENDED INPUT ---
// --- CONTENT BELOW THIS LINE IS USED TO GENERATE OUTPUTS ---

/// (Generated) Command to run in the container image.
fixed command: List<String> = List(containerCommand[0])

/// (Generated) Arguments to provide to the command that runs in the container image.
fixed args: List<String> = containerCommand.toList().sublist(1, containerCommand.length)

abstract class PublishConfig {
  /// Image tag for the version of the publish package to use.
  hidden versionTag: String

  /// Container image to run the logic of the publish step.
  fixed containerImage: String

  /// Full command to run for the publish step, as a list rather than spaced.
  fixed containerCommand: Listing<String>

  /// (Optional) Override the default IfNotPresent policy.
  fixed containerImagePullPolicy: ImagePullPolicy = "IfNotPresent"

  /// (Generated) Command to run in the container image.
  fixed command: List<String> = List(containerCommand[0])

  /// (Generated) Arguments to provide to the command that runs in the container image.
  fixed args: List<String> = containerCommand.toList().sublist(1, containerCommand.length)

  /// (Optional) Input artifacts that the publish package will consume.
  fixed inputArtifacts: Listing<FrameworkRenderer.NamedPair>

  /// (Optional) Outputs produced by the publish package.
  fixed outputs: WorkflowOutputs?

  /// (Optional) Parameters to pass through to the publish package.
  fixed parameters: Map<String, String>?

  /// Transfer a value from a UI configuration input as the setting for this publish config.
  /// - `uiConfig` the package's UI configuration
  /// - `name` the name of the property in the package's UI configuration to transfer
  function transferConfigInput(uiConfig: UIConfig, name: String): String =
    if (!uiConfig.properties.containsKey(name))
      throw("Invalid UI configuration property when trying to transfer a config input -- ensure the name matches a UI input: " + name)
    else
      "{{inputs.parameters." + name + "}}"

  /// Transfer an output file produced by the package as the setting for this publish config.
  /// - `outputs` the package's outputs
  /// - `name` the name (key) of the output file produced by the package
  /// - `rename` (optional) new name to give the output file after transferring it
  function transferFile(outputs: WorkflowOutputs?, name: String, rename: String?): FrameworkRenderer.NamePathPair =
    if (outputs == null || !outputs.files.containsKey(name))
      throw("Invalid file reference when trying to transfer a file -- ensure the name matches an output from the package: " + name)
    else
      let (nm = name)
        new FrameworkRenderer.NamePathPair {
          name = nm
          path = if (rename != null) "/tmp/\(rename)" else outputs.files.getOrNull(name)!!
        }
}

/// Use an asset import step as the final publish phase for the package.
class AssetImport extends PublishConfig {

  /// File containing assets to import, typically passed through using [transferFile()].
  hidden assetsFile: FrameworkRenderer.NamePathPair? = null

  /// Whether to allow the creation of new assets from the input CSV (full or partial assets), or ensure assets are only updated if they already exist in Atlan.
  hidden assetsUpsertSemantic: ImportSemantic?|String? = null

  /// Whether to treat the input file as an initial load, full replacement (deleting any existing assets not in the file) or only incremental (no deletion of existing assets).
  hidden assetsDeltaSemantic: DeltaSemantic?|String? = null

  /// How to delete any assets not found in the latest file.
  hidden assetsDeltaRemovalType: RemovalType?|String? = null

  /// Which assets to reload from the latest input CSV file. Changed assets only will calculate which assets have changed between the files and only attempt to reload those changes.
  hidden assetsDeltaReloadCalculation: ReloadCalculation?|String? = null

  /// Path to a direct file (locally) to use for delta processing.
  ///
  /// Note: providing a value for this will ignore any other previously-processed file in the object store,
  /// so please be sure this is the option you want to use (should be rare).
  hidden assetsPreviousFileDirect: FrameworkRenderer.NamePathPair? = null

  /// Object store prefix in which previous files exist for delta processing.
  hidden assetsPreviousFilePrefix: String? = null

  /// Options to optimize how assets are imported.
  hidden assetsConfig: ConfigType?|String? = null

  /// List of attributes you want to clear (remove) from assets if their value is blank in the provided file.
  hidden assetsAttrToOverwrite: Listing<String>?|String? = null

  /// Whether an invalid value in a field should cause the import to fail (true) or log a warning, skip that value, and proceed (false).
  hidden assetsFailOnErrors: Boolean?|String? = null

  /// Whether to use case-sensitive matching when running in update-only mode (true) or try case-insensitive matching (false).
  hidden assetsCaseSensitive: Boolean?|String? = null

  /// Whether to treat tables, views and materialized views as interchangeable (true) or strictly adhere to specified types in the input (false).
  hidden assetsTableViewAgnostic: Boolean?|String? = null

  /// Single character used to separate fields in the input file (for example, ',' or ';').
  hidden assetsFieldSeparator: String? = null

  /// How custom metadata in the input should be handled: ignore it, merge it with any existing asset custom metadata, or overwrite the existing asset custom metadata.
  hidden assetsCmHandling: CustomMetadataSemantic?|String? = null

  /// How Atlan tags on assets in the input should be handled: ignore them, append them to any existing asset tags, replace the existing asset tags, or remove them from the assets.
  hidden assetsTagHandling: AtlanTagSemantic?|String? = null

  /// How linked resources on assets in the input should be updated: based on their unique URL or their unique name.
  hidden assetsLinkIdempotency: LinkIdempotencyInvariant?|String? = null

  /// Maximum number of rows to process at a time (per API request).
  hidden assetsBatchSize: Int?|String? = null

  /// Whether to track details about every asset across batches (true) or only counts (false).
  hidden trackBatches: Boolean?|String? = null

  /// File containing glossaries, categories and terms to import; typically passed through using [transferFile()].
  hidden glossariesFile: FrameworkRenderer.NamePathPair? = null

  /// Whether to allow the creation of new glossaries, categories and terms from the input CSV, or ensure these are only updated if they already exist in Atlan.
  hidden glossariesUpsertSemantic: ImportSemantic?|String? = null

  /// Options to optimize how glossaries, categories and terms are imported.
  hidden glossariesConfig: ConfigType?|String? = null

  /// List of attributes you want to clear (remove) from glossaries, categories and terms if their value is blank in the provided file.
  hidden glossariesAttrToOverwrite: Listing<String>?|String? = null

  /// Whether an invalid value in a field should cause the import to fail (true) or log a warning, skip that value, and proceed (false).
  hidden glossariesFailOnErrors: Boolean?|String? = null

  /// Single character used to separate fields in the input file (for example, ',' or ';').
  hidden glossariesFieldSeparator: String? = null

  /// How custom metadata in the input should be handled: ignore it, merge it with any existing asset custom metadata, or overwrite the existing asset custom metadata.
  hidden glossariesCmHandling: CustomMetadataSemantic?|String? = null

  /// How Atlan tags on assets in the input should be handled: ignore them, append them to any existing asset tags, replace the existing asset tags, or remove them from the assets.
  hidden glossariesTagHandling: AtlanTagSemantic?|String? = null

  /// How linked resources on glossaries in the input should be updated: based on their unique URL or their unique name.
  hidden glossariesLinkIdempotency: LinkIdempotencyInvariant?|String? = null

  /// Maximum number of rows to process at a time (per API request).
  hidden glossariesBatchSize: Int?|String? = null

  /// File containing data domains and data products to import; typically passed through using [transferFile()].
  hidden dataProductsFile: FrameworkRenderer.NamePathPair? = null

  /// Whether to allow the creation of new domains and data products from the input CSV, or ensure these are only updated if they already exist in Atlan.
  hidden dataProductsUpsertSemantic: ImportSemantic?|String? = null

  /// Options to optimize how domains and data products are imported.
  hidden dataProductsConfig: ConfigType?|String? = null

  /// Select attributes you want to clear (remove) from domains and data products if their value is blank in the provided file.
  hidden dataProductsAttrToOverwrite: Listing<String>?|String? = null

  /// Whether an invalid value in a field should cause the import to fail (true) or log a warning, skip that value, and proceed (false).
  hidden dataProductsFailOnErrors: Boolean?|String? = null

  /// Single character used to separate fields in the input file (for example, ',' or ';').
  hidden dataProductsFieldSeparator: String? = null

  /// How custom metadata in the input should be handled: ignore it, merge it with any existing asset custom metadata, or overwrite the existing asset custom metadata.
  hidden dataProductsCmHandling: CustomMetadataSemantic?|String? = null

  /// How Atlan tags on assets in the input should be handled: ignore them, append them to any existing asset tags, replace the existing asset tags, or remove them from the assets.
  hidden dataProductsTagHandling: AtlanTagSemantic?|String? = null

  /// How linked resources on assets in the input should be updated: based on their unique URL or their unique name.
  hidden dataProductsLinkIdempotency: LinkIdempotencyInvariant?|String? = null

  /// Maximum number of rows to process at a time (per API request).
  hidden dataProductsBatchSize: Int?|String? = null

  /// File containing tag definitions to manage; typically passed through using [transferFile()].
  hidden tagsFile: FrameworkRenderer.NamePathPair? = null

  /// Options to optimize how tag definitions are imported.
  hidden tagsConfig: ConfigType?|String? = null

  /// Whether an invalid value in a field should cause the import to fail (true) or log a warning, skip that value, and proceed (false).
  hidden tagsFailOnErrors: Boolean?|String? = null

  /// Single character used to separate fields in the input file (for example, ',' or ';').
  hidden tagsFieldSeparator: String? = null

  /// Maximum number of rows to process at a time (per API request).
  hidden tagsBatchSize: Int?|String? = null

  fixed inputArtifacts {
    when (assetsFile != null) { assetsFile }
    when (glossariesFile != null) { glossariesFile }
    when (dataProductsFile != null) { dataProductsFile }
    when (tagsFile != null) { tagsFile }
  }
  fixed outputs {
    files {
      ["debug-logs"] = "/tmp/debug.log"
      ["results"] = "/tmp/results.csv"
    }
  }
  fixed containerImage = "ghcr.io/atlanhq/csa-asset-import:\(versionTag)"
  fixed containerCommand {
    "/dumb-init"
    "--"
    "java"
    "com.atlan.pkg.aim.Importer"
  }

  fixed parameters: Map<String, String> = new Mapping {
    ["import_type"] = "DIRECT"
    when (assetsFile != null) { ["assets_file"] = assetsFile.path }
    when (assetsUpsertSemantic != null) { ["assets_upsert_semantic"] = assetsUpsertSemantic }
    when (assetsDeltaSemantic != null) { ["assets_delta_semantic"] = assetsDeltaSemantic.toString() }
    when (assetsDeltaRemovalType != null) { ["assets_delta_removal_type"] = assetsDeltaRemovalType.toString() }
    when (assetsDeltaReloadCalculation != null) { ["assets_delta_reload_calculation"] = assetsDeltaReloadCalculation.toString() }
    when (assetsPreviousFileDirect != null) { ["assets_previous_file_direct"] = assetsPreviousFileDirect.path }
    when (assetsPreviousFilePrefix != null) { ["assets_previous_file_prefix"] = assetsPreviousFilePrefix }
    when (assetsConfig != null) { ["assets_config"] = assetsConfig }
    when (assetsAttrToOverwrite != null) {
      when (assetsAttrToOverwrite is Listing) {
        ["assets_attr_to_overwrite"] = "[\"" + assetsAttrToOverwrite.join("\",\"") + "\"]"
      } else {
        ["assets_attr_to_overwrite"] = assetsAttrToOverwrite
      }
    }
    when (assetsFailOnErrors != null) { ["assets_fail_on_errors"] = assetsFailOnErrors.toString() }
    when (assetsCaseSensitive != null) { ["assets_case_sensitive"] = assetsCaseSensitive.toString() }
    when (assetsTableViewAgnostic != null) { ["assets_table_view_agnostic"] = assetsTableViewAgnostic.toString() }
    when (assetsFieldSeparator != null) { ["assets_field_separator"] = assetsFieldSeparator }
    when (assetsBatchSize != null) { ["assets_batch_size"] = assetsBatchSize.toString() }
    when (assetsCmHandling != null) { ["assets_cm_handling"] = assetsCmHandling }
    when (assetsTagHandling != null) { ["assets_tag_handling"] = assetsTagHandling }
    when (assetsLinkIdempotency != null) { ["assets_link_idempotency"] = assetsLinkIdempotency }
    when (trackBatches != null) { ["track_batches"] = trackBatches.toString() }

    when (glossariesFile != null) { ["glossaries_file"] = glossariesFile.path }
    when (glossariesUpsertSemantic != null) { ["glossaries_upsert_semantic"] = glossariesUpsertSemantic }
    when (glossariesConfig != null) { ["glossaries_config"] = glossariesConfig }
    when (glossariesAttrToOverwrite != null) {
      when (glossariesAttrToOverwrite is Listing) {
        ["glossaries_attr_to_overwrite"] = "[\"" + glossariesAttrToOverwrite.join("\",\"") + "\"]"
      } else {
        ["glossaries_attr_to_overwrite"] = glossariesAttrToOverwrite
      }
    }
    when (glossariesFailOnErrors != null) { ["glossaries_fail_on_errors"] = glossariesFailOnErrors.toString() }
    when (glossariesFieldSeparator != null) { ["glossaries_field_separator"] = glossariesFieldSeparator }
    when (glossariesCmHandling != null) { ["glossaries_cm_handling"] = glossariesCmHandling }
    when (glossariesTagHandling != null) { ["glossaries_tag_handling"] = glossariesTagHandling }
    when (glossariesLinkIdempotency != null) { ["glossaries_link_idempotency"] = glossariesLinkIdempotency }
    when (glossariesBatchSize != null) { ["glossaries_batch_size"] = glossariesBatchSize.toString() }

    when (dataProductsFile != null) { ["data_products_file"] = dataProductsFile.path }
    when (dataProductsUpsertSemantic != null) { ["data_products_upsert_semantic"] = dataProductsUpsertSemantic }
    when (dataProductsConfig != null) { ["data_products_config"] = dataProductsConfig }
    when (dataProductsAttrToOverwrite != null) {
      when (dataProductsAttrToOverwrite is Listing) {
        ["data_products_attr_to_overwrite"] = "[\"" + dataProductsAttrToOverwrite.join("\",\"") + "\"]"
      } else {
        ["data_products_attr_to_overwrite"] = dataProductsAttrToOverwrite
      }
    }
    when (dataProductsFailOnErrors != null) { ["data_products_fail_on_errors"] = dataProductsFailOnErrors.toString() }
    when (dataProductsFieldSeparator != null) { ["data_products_field_separator"] = dataProductsFieldSeparator }
    when (dataProductsCmHandling != null) { ["data_products_cm_handling"] = dataProductsCmHandling }
    when (dataProductsTagHandling != null) { ["data_products_tag_handling"] = dataProductsTagHandling }
    when (dataProductsLinkIdempotency != null) { ["data_products_link_idempotency"] = dataProductsLinkIdempotency }
    when (dataProductsBatchSize != null) { ["data_products_batch_size"] = dataProductsBatchSize.toString() }

    when (tagsFile != null) { ["tags_file"] = tagsFile.path }
    when (tagsConfig != null) { ["tags_config"] = tagsConfig }
    when (tagsFailOnErrors != null) { ["tags_fail_on_errors"] = tagsFailOnErrors.toString() }
    when (tagsFieldSeparator != null) { ["tags_field_separator"] = tagsFieldSeparator }
    when (tagsBatchSize != null) { ["tags_batch_size"] = tagsBatchSize.toString() }
  }.toMap()
}

/// Use a relational assets builder step as the final publish phase for the package.
class RelationalAssetsBuilder extends PublishConfig {

  /// File containing assets to import, typically passed through using [transferFile()].
  hidden assetsFile: FrameworkRenderer.NamePathPair? = null

  /// Whether to allow the creation of new (full or partial) assets from the input CSV, or ensure assets are only updated if they already exist in Atlan.
  hidden assetsUpsertSemantic: ImportSemantic?|String? = null

  /// Whether to treat the input file as an initial load, full replacement (deleting any existing assets not in the file) or only incremental (no deletion of existing assets).
  hidden deltaSemantic: DeltaSemantic?|String? = null

  /// How to delete any assets not found in the latest file.
  hidden deltaRemovalType: RemovalType?|String? = null

  /// Which assets to reload from the latest input CSV file. Changed assets only will calculate which assets have changed between the files and only attempt to reload those changes.
  hidden deltaReloadCalculation: ReloadCalculation?|String? = null

  /// Path to a direct file (locally) to use for delta processing.
  ///
  /// Note: providing a value for this will ignore any other previously-processed file in the object store,
  /// so please be sure this is the option you want to use (should be rare).
  hidden previousFileDirect: FrameworkRenderer.NamePathPair? = null

  /// List of attributes you want to clear (remove) from assets if their value is blank in the provided file.
  hidden assetsAttrToOverwrite: Listing<String>?|String? = null

  /// Whether an invalid value in a field should cause the import to fail (true) or log a warning, skip that value, and proceed (false).
  hidden assetsFailOnErrors: Boolean?|String? = null

  /// Single character used to separate fields in the input file (for example, ',' or ';').
  hidden assetsFieldSeparator: String? = null

  /// Maximum number of rows to process at a time (per API request).
  hidden assetsBatchSize: Int?|String? = null

  /// How custom metadata in the input should be handled: ignore it, merge it with any existing asset custom metadata, or overwrite the existing asset custom metadata.
  hidden assetsCmHandling: CustomMetadataSemantic?|String? = null

  /// How Atlan tags on assets in the input should be handled: ignore them, append them to any existing asset tags, replace the existing asset tags, or remove them from the assets.
  hidden assetsTagHandling: AtlanTagSemantic?|String? = null

  /// Whether to track details about every asset across batches (true) or only counts (false).
  hidden trackBatches: Boolean?|String? = null

  fixed inputArtifacts {
    when (assetsFile != null) { assetsFile }
  }
  fixed outputs {
    files {
      ["debug-logs"] = "/tmp/debug.log"
      ["transformed_file"] = "/tmp/current-file-transformed.csv"
    }
  }
  fixed containerImage = "ghcr.io/atlanhq/csa-relational-assets-builder:\(versionTag)"
  fixed containerCommand {
    "/dumb-init"
    "--"
    "java"
    "com.atlan.pkg.rab.Importer"
  }

  fixed parameters: Map<String, String> = new Mapping {
    ["import_type"] = "DIRECT"
    when (assetsFile != null) { ["assets_file"] = assetsFile.path }
    when (assetsUpsertSemantic != null) { ["assets_upsert_semantic"] = assetsUpsertSemantic }
    when (deltaSemantic != null) { ["delta_semantic"] = deltaSemantic.toString() }
    when (deltaRemovalType != null) { ["delta_removal_type"] = deltaRemovalType.toString() }
    when (deltaReloadCalculation != null) { ["delta_reload_calculation"] = deltaReloadCalculation.toString() }
    when (previousFileDirect != null) { ["previous_file_direct"] = previousFileDirect.path }
    when (assetsAttrToOverwrite != null) {
      when (assetsAttrToOverwrite is Listing) {
        ["assets_attr_to_overwrite"] = "[\"" + assetsAttrToOverwrite.join("\",\"") + "\"]"
      } else {
        ["assets_attr_to_overwrite"] = assetsAttrToOverwrite
      }
    }
    when (assetsFailOnErrors != null) { ["assets_fail_on_errors"] = assetsFailOnErrors.toString() }
    when (assetsFieldSeparator != null) { ["assets_field_separator"] = assetsFieldSeparator }
    when (assetsBatchSize != null) { ["assets_batch_size"] = assetsBatchSize.toString() }
    when (assetsCmHandling != null) { ["assets_cm_handling"] = assetsCmHandling }
    when (assetsTagHandling != null) { ["assets_tag_handling"] = assetsTagHandling }
    when (trackBatches != null) { ["track_batches"] = trackBatches.toString() }
  }.toMap()
}

/// Use a lineage builder step as the final publish phase for the package.
class LineageBuilder extends PublishConfig {

  /// File containing lineage to import, typically passed through using [transferFile()].
  hidden lineageFile: FrameworkRenderer.NamePathPair? = null

  /// Whether to allow the creation of new (full or partial) assets from the input CSV, or ensure assets are only updated if they already exist in Atlan.
  hidden lineageUpsertSemantic: ImportSemantic?|String? = null

  /// Whether an invalid value in a field should cause the import to fail (true) or log a warning, skip that value, and proceed (false).
  hidden lineageFailOnErrors: Boolean?|String? = null

  /// Single character used to separate fields in the input file (for example, ',' or ';').
  hidden fieldSeparator: String? = null

  /// Maximum number of rows to process at a time (per API request).
  hidden batchSize: Int?|String? = null

  /// How custom metadata in the input should be handled: ignore it, merge it with any existing asset custom metadata, or overwrite the existing asset custom metadata.
  hidden cmHandling: CustomMetadataSemantic?|String? = null

  /// How Atlan tags on assets in the input should be handled: ignore them, append them to any existing asset tags, replace the existing asset tags, or remove them from the assets.
  hidden tagHandling: AtlanTagSemantic?|String? = null

  fixed inputArtifacts {
    when (lineageFile != null) { lineageFile }
  }
  fixed outputs {
    files {
      ["debug-logs"] = "/tmp/debug.log"
    }
  }
  fixed containerImage = "ghcr.io/atlanhq/csa-lineage-builder:\(versionTag)"
  fixed containerCommand {
    "/dumb-init"
    "--"
    "java"
    "com.atlan.pkg.lb.Loader"
  }

  fixed parameters: Map<String, String> = new Mapping {
    ["import_type"] = "DIRECT"
    when (lineageFile != null) { ["lineage_file"] = lineageFile.path }
    when (lineageUpsertSemantic != null) { ["lineage_upsert_semantic"] = lineageUpsertSemantic }
    when (lineageFailOnErrors != null) { ["lineage_fail_on_errors"] = lineageFailOnErrors.toString() }
    when (fieldSeparator != null) { ["field_separator"] = fieldSeparator }
    when (batchSize != null) { ["batch_size"] = batchSize.toString() }
    when (cmHandling != null) { ["cm_handling"] = cmHandling }
    when (tagHandling != null) { ["tag_handling"] = tagHandling }
  }.toMap()
}

/// Configuration for the UI of the custom package.
///
/// | Variable | | Usage |
/// |---|---|---|
/// | **[tasks][UIStep]** | | Mapping of top-level tasks to be configured, keyed by the name of the task as it should appear in the UI. |
/// | **[rules][UIRule]** | | Listing of rules to control which [inputs][UIElement] appear based on values selected in other inputs. |
class UIConfig {

  /// Mapping of top-level tasks to be configured, keyed by the name of the task as it should appear in the UI.
  ///
  /// Remember in Pkl to define a mapping, put the key in square brackets and the value in curly braces:
  /// ```
  /// tasks {
  ///   ["Input"] {
  ///     ...
  ///   }
  ///   ["Delivery"] {
  ///     ...
  ///   }
  ///   ...
  /// }
  /// ```
  hidden tasks: Mapping<String, UIStep>

  /// (Generated) Details of all inputs across all steps for the UI.
  fixed properties: Map<String, UIElement> = new Mapping {
    for (_, step in tasks) {
      // Note: using spread syntax to error on any duplicates across steps
      ...?step.inputs
    }
  }.toMap()

  /// Listing of rules to control which [inputs][UIElement] appear based on values selected in other inputs.
  ///
  /// Remember in Pkl to define a listing, use curly braces and create new elements within:
  /// ```
  /// rules {
  ///   new UIRule {
  ///     whenInputs { ["export_scope"] = "ENRICHED_ONLY" }
  ///     required = { "qn_prefix" }
  ///   }
  ///   new UIRule {
  ///     ...
  ///   }
  ///   ...
  /// }
  /// ```
  hidden rules: Listing<UIRule> = new Listing {}

  /// (Generated) Details of all UI rules to use to control the UI.
  fixed anyOf: List<UIRule>? = if (rules.isEmpty) null else rules.toList()

  /// (Generated) Details about each task (top-level step) to use in the UI.
  fixed steps: List<UIStep> = tasks.fold(List(), (acc: List<UIStep>, key, value) ->
    acc.add(resolveStep(key, value))
  )
}

const function resolveInputs(inputs: Mapping<String, UIElement>): Mapping<String, UIElement> = inputs.fold(new Mapping {}, (acc: Mapping<String, UIElement>, inputKey, input) ->
  (acc) {
    [inputKey] = input
  }
)

const function resolveStep(stepName: String, step: UIStep): UIStep = (step) {
  title = stepName
}

/// Configure a top-level step in the UI for the package.
///
/// | Field | | Description |
/// |---|---|---|
/// | **`title`** | | name to show in the UI for the step |
/// | `description` | | description to show in the UI for the step |
/// | **[inputs][UIElement]** | | mapping of inputs to be configured for the step, keyed by a unique (variable) name for the input |
class UIStep {

  /// Name to show in the UI for the step.
  /// This will be set automatically from the key of the outer map in which this step is defined.
  title: String

  /// Description to show in the UI for the step.
  description: String = ""

  /// Mapping of [inputs][UIElement] to be configured for the step, keyed by a unique (variable) name for the input.
  /// Note: the name of the variable (key of the map) should be in lower_snake_case.
  ///
  /// Remember in Pkl to define a mapping, put the key in square brackets and the value in curly braces:
  /// ```
  /// inputs {
  ///   ["export_scope"] = new Radio {
  ///     ...
  ///   }
  ///   ["qn_prefix"] = new TextInput {
  ///     ...
  ///   }
  ///   ...
  /// }
  /// ```
  hidden inputs: Mapping<String(lower_snake_case), UIElement>

  /// (Generated) Unique identifier for the step.
  fixed id = title.replaceAll(" ", "_").toLowerCase()

  /// (Generated) List of inputs contained within the step.
  fixed properties: List<String> = inputs.fold(List(), (acc, key, _) -> acc.add(key))
}

/// Validates the provided string value is in snake_case.
local const lower_snake_case = (str) -> str.matches(Regex("[a-z0-9_]*"))

/// Configure basic UI rules that when the specified inputs have specified values, certain
/// other fields become required.
///
/// | Field | | Description |
/// |---|---|---|
/// | **`whenInputs`** | | mapping from input ID to value for the step |
/// | **`required`** | | list of input IDs that should become required when the inputs all match |
class UIRule {
  fixed properties: Mapping<String, Mapping<String, String>> = new Mapping {
    for (k, v in whenInputs) {
      [k] = new Mapping {
        ["const"] = v
      }
    }
  }

  /// Mapping from input ID (variable name for the input) to value for the step
  hidden whenInputs: Mapping<String, String>

  /// List of input IDs (variable names) that should become required when the inputs all match
  required: Listing<String>
}

/// Class defining any outputs the package's logic will produce.
class WorkflowOutputs {
  /// Files the package will produce in the local filesystem.
  hidden files: Mapping<String, String>?

  /// Outputs the package will produce into S3.
  s3Objects: Listing<S3Artifact>?

  /// (Generated) List of all artifacts the package will produce.
  fixed artifacts: List<FrameworkRenderer.NamedPair> = (s3Objects?.toList() ?? List())
    + (files?.fold(List(), (acc: List<FrameworkRenderer.NamedPair>, key, value) ->
        acc.add(new FrameworkRenderer.NamePathPair {
          name=key
          path=value
        })) ?? List())
}

class S3Artifact extends FrameworkRenderer.NamedPair {
  /// Name of the object in S3
  name: String

  /// Path on the container's local filesystem for the object
  path: String = "/tmp/\(name).json"

  /// (Optional) Configuration for how the S3 object should be archived.
  archive: Mapping<String, Mapping<String, String>> = new Mapping {
    ["none"] = new Mapping {}
  }

  /// (Optional) Configuration for how the S3 object should be mapped.
  s3: Mapping<String, String> = new Mapping {
    ["key"] = "{{inputs.parameters.\(FrameworkRenderer.S3_CONFIG_PREFIX)}}/\(name).json"
  }

  /// (Optional) Configuration for how the S3 object should be garbage collected.
  artifactGC: Mapping<String, String> = new Mapping {
    ["strategy"] = "OnWorkflowDeletion"
  }
}

/// Image pull policy for the container image.
/// For more details on behavior, see: https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy
typealias ImagePullPolicy = "Always"|"IfNotPresent"|"Never"

/// Coding languages the toolkit can generate strongly-typed configuration hand-over classes for.
typealias CodeLanguage = "Java"|"Kotlin"|"Python"|"Other"

/// Options for the semantic to use when importing (publishing) assets in Atlan.
typealias ImportSemantic = "upsert"|"update"|"partial"

/// Options for the semantic to use when doing delta-calculations for loading assets into Atlan.
typealias DeltaSemantic = "full"|"delta"

/// Options for how assets should be removed when they are no longer detected via a delta calculation.
typealias RemovalType = "archive"|"purge"

/// Options for which assets should be reloaded after calculating a delta.
typealias ReloadCalculation = "all"|"changes"

/// Options for the semantic to use when loading custom metadata on assets into Atlan.
typealias CustomMetadataSemantic = "ignore"|"overwrite"|"merge"

/// Options for the semantic to use when loading Atlan tag associations to assets into Atlan.
typealias AtlanTagSemantic = "ignore"|"append"|"replace"|"remove"

/// Options for which part of a linked resource should be considered unique, to use for updating a link's details.
typealias LinkIdempotencyInvariant = "url"|"name"

/// Configuration type for a package.
typealias ConfigType = "default"|"advanced"

/// (Generated) Unique name to use for file-based objects for the package.
hidden fixed name = packageId.replaceAll("@", "").replaceAll("/", "-")

const function getPythonPkgName(m): String = getLowerSnakeCase(getPascalCase(m.packageName))

/// Set up multiple outputs for the module, one for each configuration file.
/// - `m` the package config to generate outputs for
const function getOutputs(m): Mapping<String, FileOutput> = new Mapping {
  ["build/package/\(m.name)/configmaps/default.yaml"] = FrameworkRenderer.getConfigMap(m)
  ["build/package/\(m.name)/templates/default.yaml"] = FrameworkRenderer.getWorkflowTemplate(m)
  ["build/package/\(m.name)/index.js"] = FrameworkRenderer.getIndexJs()
  ["build/package/\(m.name)/package.json"] = FrameworkRenderer.getPackageJson(m)
  when (m.implementationLanguage == "Kotlin" || m.implementationLanguage == "Java") {
    ["src/main/kotlin/\(getClassName(m.packageName)).kt"] = FrameworkRenderer.getConfigClassKt(m, getClassName(m.packageName))
  }
  when (m.implementationLanguage == "Python") {
    ["\(getPythonPkgName(m))/\(getPythonPkgName(m))_cfg.py"] = FrameworkRenderer.getConfigClassPy(m)
    ["\(getPythonPkgName(m))/__init__.py"] = FrameworkRenderer.getBlankFile()
    ["\(getPythonPkgName(m))/main.py.example"] = FrameworkRenderer.getMainPy(getPythonPkgName(m))
    ["\(getPythonPkgName(m))/logging.conf"] = FrameworkRenderer.getLoggingConfPy()
    ["requirements.txt.example"] = FrameworkRenderer.getRequirementsPy()
    ["requirements-dev.txt.example"] = FrameworkRenderer.getRequirementsDevPy()
    ["version.txt"] = FrameworkRenderer.getVersionPy(m)
    ["Dockerfile"] = FrameworkRenderer.getDockerfilePy(getPythonPkgName(m))
  }
}

/// Translate the model content into a set of files for both type definitions (JSON)
/// and UI configuration (TypeScript).
const function getModuleOutput(m): ModuleOutput = new ModuleOutput {
  files = getOutputs(m)
}

/// Set the output of the module to be separate files for each custom type definition in the model.
output = getModuleOutput(this)

/// Turn the provided name into a PascalCase name.
const function getPascalCase(name: String): String =
  name.split(Regex("[\\W_]+")).map((word) -> word.capitalize()).join("")

/// Turn the provided name into a lower_snake_case_name.
const function getLowerSnakeCase(text: String): String = getSnakeCase(text).toLowerCase()
local const function getSnakeCase(text: String): String =
  text.replaceAll("_", "").replaceAll(Regex("([A-Z0-9]+)([A-Z][a-z][0-9])"), "$1_$2").replaceAll(Regex("([a-z0-9])([A-Z0-9])"), "$1_$2")

const function getClassName(name: String): String = "\(getPascalCase(name))Cfg"

// --- WIDGETS ---
/// Base class for all UI elements that can be used in the configuration of a package.
///
/// You will not use this class directly, but will use one of its subclasses:
///
/// | Widget | | Usage |
/// |---|---|---|
/// | [APITokenSelector] | | select an existing API token from a drop-down list, and returns the GUID of the selected API token |
/// | [AgentSelector] | | select a configured secure agent from a drop-down list |
/// | [BooleanInput] | | choose either "Yes" or "No", and returns the value that was selected |
/// | [ConnectionCreator] | | create a new connection by providing a name and list of admins, and returns a string representation of the connection object that should be created |
/// | [ConnectionSelector] | | select an existing connection from a drop-down list, and returns the qualified name of the selected connection |
/// | [ConnectorTypeSelector] | | select from the types of connectors that exist in the tenant (for example "Snowflake"), without needing to select a specific instance of a connection (for example, the "production" connection for Snowflake); will return a string-encoded object giving the connection type that was selected and a list of all connections in the tenant that have that type |
/// | [CredentialInput] | | enter sensitive credential information that will be encrypted and protected in Atlan's Vault, and returns the GUID of the entry in the Vault |
/// | [DateInput] | | enter or select a date (not including time) from a calendar, and returns the epoch-based number representing that selected date in seconds |
/// | [DropDown] | | select from a drop-down of provided options |
/// | [FileCopier] | | copy a file from the tenant's S3 bucket, and returns the name of the file (as it is named in S3) |
/// | [FileUploader] | | upload a file, and returns the GUID-based name of the file (as it is renamed after upload) |
/// | [KeygenInput] | | generate a unique key that could be used for securing an exchange or other unique identification purposes, and provides buttons to regenerate the key or copy its text; will return the generated key as clear text |
/// | [MultipleGroups] | | choose multiple groups, and returns an array of group names that were selected |
/// | [MultipleUsers] | | choose multiple users, and returns an array of usernames that were selected |
/// | [NumericInput] | | enter an arbitrary number into a single-line text input field, and returns the value of the number that was entered |
/// | [PasswordInput] | | enter arbitrary text, but the text will be shown as dots when entered rather than being displayed in clear text; will return the entered text in clear text |
/// | [Radio] | | select just one option from a set of options, and returns the key of the selected option (typically, this is used to control mutually exclusive options in the UI) |
/// | [SingleGroup] | | select a single group, and returns the group name of the selected group |
/// | [SingleUser] | | select a single user, and returns the username of the selected user |
/// | [TextInput] | | enter arbitrary text into a single-line text input field, and returns the value of the text that was entered |
abstract class UIElement {
  /// Type of the element, which can be used to determine how to render it in the UI.
  fixed type: String

  /// Name to show in the UI for the widget.
  hidden title: String

  /// Whether a value must be selected to proceed with the UI setup.
  required: Boolean = false

  /// Whether the widget will be shown in the UI (false) or not (true).
  hidden hide: Boolean = false

  /// Informational text to place in a hover-over to describe the use of the input.
  hidden helpText: String = ""

  /// Sizing of the input on the UI (8 is full-width, 4 is half-width).
  hidden width: Int = 8

  /// Default fallback value to use for the element if nothing is selected or entered in the UI.
  hidden fallback: Any? = null

  /// (Generated) UI configuration for the element.
  fixed ui: Widget = new Widget {
    label = title
    `hidden` = hide
    help = helpText
    grid = width
  }
}

/// Base class for all UI elements that use some enumeration of valid values.
abstract class UIElementWithEnum extends UIElement {

  /// Mapping of possible values for the input, keyed by a unique (variable) name for the value.
  hidden possibleValues: Mapping<String, String>

  /// Default value to select in the input.
  default: String?

  /// (Generated) Listing of the unique variable names for the possible values.
  fixed enum: List<String> = possibleValues.fold(List(), (acc: List<String>, key, _) -> acc.add(key))

  /// (Generated) Listing of the display values for each possible value.
  fixed enumNames: List<String> = possibleValues.fold(List(), (acc: List<String>, _, value) -> acc.add(value))
}

/// Base class for all generated elements of the UI.
class Widget {

  /// Internal name of this widget, that controls what kind of widget is rendered in the UI.
  widget: String

  /// Label to show in the UI for the widget.
  label: String

  /// Whether the widget will be shown in the UI (false) or not (true).
  `hidden`: Boolean = false

  /// Informational text to place in a hover-over to describe the use of the input.
  help: String = ""

  /// Example text to place within the widget to exemplify its use.
  placeholder: String?

  /// Sizing of the input on the UI (8 is full-width, 4 is half-width).
  grid: Int = 8

  /// Mode of the widget, if applicable (usually whether something allows multiple selections or only a single selection).
  mode: String?

  /// TBC
  start: Int?

  /// List of the mime-types of files that should be accepted.
  accept: List<String>?

  /// Whether the widget should return file metadata.
  fileMetadata: Boolean?

  /// Most distant past value that can be selected through the widget.
  min: Int?

  /// Most distant future value that can be selected through the widget.
  max: Int?

  /// Default value to select in the widget.
  default: Any?

  /// Type of credential to be nested within the widget.
  credentialType: String?

  /// TBC
  nestedValue: Boolean?

  /// Fixed string that should appear (immutable) before the input box.
  addonBefore: String?

  /// Whether the value can be changed (false) or is immutable (true).
  disabled: Boolean?

  /// SQL query to run to determine the widget's selectable content.
  query: String?

  /// Whether to prevent the Test Authentication button from showing (true) or show it (false) for credential inputs.
  isTestAuthenticationDisabled: Boolean?

  /// Whether to show all API tokens for the APITokenSelector (true) or only those created directly by the user (false).
  shouldShowAllKeys: Boolean?

  /// If set, only connections with a connector of the type specified will be shown in the ConnectionSelector
  /// (otherwise all connections will be shown).
  connectorName: String?|List<String>? = null

  /// Type of credential to be used for an API tree widget.
  connectorConfigName: String?

  /// Name of the variable holding credential details for an API tree widget.
  credential: String?

  /// Key to use in the API tree widget's credential for transformation.
  metadataTransformerTemplateKey: String?

  /// Key to use in the API tree widget's credential for metadata retrieval.
  metadataTemplateKey: String?

  /// Whether to flatten the values retrieved from the API.
  flattenValue: Boolean?

  /// Whether to strictly check the tree retrieved via the API.
  treeCheckStrictly: Boolean?

  /// Whether multiple options can be selected (true) or only a single option (false).
  isMultiple: Boolean?
}

/// Widget that allows you to enter arbitrary text into a single-line text input field,
/// and returns the value of the text that was entered.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `placeholderText` | | example text to place within the widget to exemplify its use | `""` |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
/// | `defaultValue` | | default value to use in the widget | |
/// | `prepend` | | fixed text to prepend to the value entered by the user | |
/// | `enabled` | | whether the value can be changed (true) or is immutable (false) | |
class TextInput extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// Example text to place within the widget to exemplify its use.
  hidden placeholderText: String = ""

  /// (Optional) Default value to use in the widget.
  hidden defaultValue: String?

  /// (Optional) Fixed text to prepend to the value entered by the user.
  hidden prepend: String?

  /// (Optional) Whether the value can be changed (true) or is immutable (false).
  hidden enabled: Boolean?

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "input"
    placeholder = placeholderText
    addonBefore = prepend
    disabled = if (enabled != null) !enabled else null
    default = defaultValue
  }
}

/// Widget that allows you to enter arbitrary text into a multi-line text input box,
/// and returns the value of the text that was entered.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `placeholderText` | | example text to place within the widget to exemplify its use | `""` |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
class TextBoxInput extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// Example text to place within the widget to exemplify its use.
  hidden placeholderText: String = ""

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "TextInput"
    placeholder = placeholderText
  }
}

/// Widget that allows you to select just one option from a set of options, and returns the key of
/// the selected option.
/// Typically, this is used to control mutually exclusive options in the UI.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | **`possibleValues`** | | possible values that can be selected in the radio button | |
/// | **`default`** | | default value to select in the radio button (its key) | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
class Radio extends UIElementWithEnum {
  fixed type = "string"

  /// Possible values that can be selected in the radio button.
  /// The key is the value that will be returned, and the value is the text to display.
  hidden possibleValues: Mapping<String, String>

  /// Default value to select in the radio button (its key).
  default: String?(if (this != null) possibleValues.keys.contains(this) else true)

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "radio"
  }
}

/// Widget that allows you to create a new connection by providing a name and list of admins,
/// and returns a string representation of the connection object that should be created.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
class ConnectionCreator extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "connection"
  }
}

/// Widget that allows you to select an existing connection from a drop-down list,
/// and returns the qualified name of the selected connection.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `multiSelect` | | whether multiple connections can be selected (true) or only a single connection (false) | `false` |
/// | `begin` | | TBC | `1` |
class ConnectionSelector extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// When set, will limit the connections shown in the drop-down to those with a connector in the provided list.
  hidden limitToConnectors: String?|List<String>? = null

  /// Whether multiple connections can be selected (true) or only a single connection (false).
  hidden multiSelect: Boolean = false

  /// TBC
  hidden begin: Int = 1

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "connectionSelector"
    mode = if (multiSelect) "multiple" else ""
    start = begin
    connectorName = limitToConnectors
  }
}

/// Widget that allows you to upload a file, and returns the GUID-based name of the file (as it is
/// renamed after upload).
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | **`fileTypes`** | | list of the mime-types of files that should be accepted | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `placeholderText` | | example text to place within the widget to exemplify its use | `""` |
class FileUploader extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// List of the mime-types of files that should be accepted.
  hidden fileTypes: Listing<String>

  /// Example text to place within the widget to exemplify its use.
  hidden placeholderText: String = ""

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "fileUpload"
    placeholder = placeholderText
    accept = fileTypes.toList()
    fileMetadata = true
  }
}

/// Widget that allows you to copy a file from the tenant's S3 bucket, and returns the name of the file
/// (as it is named in S3).
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be entered to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `placeholderText` | | example text to place within the widget to exemplify its use | `""` |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
class FileCopier extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// Example text to place within the widget to exemplify its use.
  hidden placeholderText: String = ""

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "input"
    placeholder = placeholderText
  }
}

/// Widget that allows you to enter an arbitrary number into a single-line text input field,
/// and returns the value of the number that was entered.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `placeholderValue` | | example value to place within the widget to exemplify its use | |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
/// | `enabled` | | whether the value can be changed (true) or is immutable (false) | |
class NumericInput extends UIElement {
  fixed type = "number"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// Example text to place within the widget to exemplify its use.
  hidden placeholderValue: Number?

  /// Default number to use in the widget.
  default: Number?

  /// (Optional) Whether the value can be changed (true) or is immutable (false).
  hidden enabled: Boolean?

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "inputNumber"
    placeholder = placeholderValue?.toString()
    disabled = if (enabled != null) !enabled else null
  }
}

/// Widget that allows you to enter or select a date (not including time) from a calendar,
/// and returns the epoch-based number representing that selected date in seconds.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `past` | | an offset from today (0) that indicates how far back in the calendar can be selected (-1 is yesterday, 1 is tomorrow, and so on) | `-14` |
/// | `future` | | an offset from today (0) that indicates how far forward in the calendar can be selected (-1 is yesterday, 1 is tomorrow, and so on) | `0` |
/// | `defaultDay` | | an offset from today that indicates the default date that should be selected in the calendar (0 is today, -1 is yesterday, 1 is tomorrow, and so on) | `0` |
/// | `begin` | | TBC | `1` |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
class DateInput extends UIElement {
  fixed type = "number"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// An offset from today (0) that indicates how far back in the calendar can be selected (-1 is yesterday, 1 is tomorrow, and so on).
  hidden past: Int = -14

  /// An offset from today (0) that indicates how far forward in the calendar can be selected (-1 is yesterday, 1 is tomorrow, and so on).
  hidden future: Int = 0

  /// An offset from today that indicates the default date that should be selected in the calendar (0 is today, -1 is yesterday, 1 is tomorrow, and so on).
  hidden defaultDay: Int = 0

  /// TBC
  hidden begin: Int = 1

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "date"
    start = begin
    min = past
    max = future
    default = defaultDay
  }
}

/// Widget that allows you to choose either "Yes" or "No",
/// and returns the value that was selected.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `defaultSelection` | | the default value to use for this boolean input | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
class BooleanInput extends UIElement {
  fixed type = "boolean"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// The default value to use for this boolean input.
  hidden defaultSelection: Boolean = false

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "boolean"
    default = defaultSelection
  }
}

/// Widget that allows you to select from a drop-down of provided options.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | **`possibleValues`** | | map of option keys to the value that will be display for each option in the drop-down | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `multiSelect` | | whether multiple options can be selected (true) or only a single option (false) | `false` |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
class DropDown extends UIElementWithEnum {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// Whether multiple values can be selected (true) or only a single value (false).
  hidden multiSelect: Boolean = false

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "select"
    mode = if (multiSelect) "multiple" else ""
  }
}

/// Widget that allows you to choose multiple groups,
/// and returns an array of group names that were selected.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
class MultipleGroups extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "groupMultiple"
  }
}

/// Widget that allows you to select a single group,
/// and returns the group name of the selected group.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
class SingleGroup extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "groups"
  }
}

/// Widget that allows you to choose multiple users,
/// and returns an array of usernames that were selected.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
class MultipleUsers extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "userMultiple"
  }
}

/// Widget that allows you to select a single user,
/// and returns the username of the selected user.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
class SingleUser extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "users"
  }
}

/// Widget that allows you to select from the types of connectors that exist in the tenant
/// (for example "Snowflake"), without needing to select a specific instance of a connection
/// (for example, the "production" connection for Snowflake). Will return a string-encoded
/// object giving the connection type that was selected and a list of all connections in the tenant
/// that have that type.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
/// | `begin` | | TBC | `1` |
class ConnectorTypeSelector extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// TBC
  hidden begin: Int = 1

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "sourceConnectionSelector"
    start = begin
  }
}

/// Widget that allows you to select an existing API token from a drop-down list,
/// and returns the GUID of the selected API token.
/// Note: currently only API tokens that were created by the user configuring the workflow
/// will appear in the drop-down list.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `showAll` | | whether to show all API tokens (true), or only those the user themself created (false) | `false` |
class APITokenSelector extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override
  hidden showAll = false

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "apiTokenSelect"
    shouldShowAllKeys = showAll
  }
}

/// Widget that allows you to generate a unique key that could be used for securing an exchange
/// or other unique identification purposes, and provides buttons to regenerate the key or copy its
/// text. Will return the generated key as clear text.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
class KeygenInput extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "keygen"
  }
}

/// Widget that allows you to enter arbitrary text, but the text will be shown as dots when entered
/// rather than being displayed in clear text. Will return the entered text in clear text.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
class PasswordInput extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "password"
  }
}

/// Widget that allows you to enter sensitive credential information that will be encrypted and protected
/// in Atlan's Vault and not be visible to anyone. Will return the GUID of the entry in the Vault.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | **`credType`** | | type of credential to be nested within the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
class CredentialInput extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// Type of credential to be nested within the widget.
  hidden credType: String

  /// Whether to show the button for testing authentication. (Default: true, show it)
  hidden allowTestAuthentication: Boolean = true

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "credential"
    credentialType = credType
    isTestAuthenticationDisabled = !allowTestAuthentication
  }
}

/// Widget that allows you to select a configured secure agent from a drop-down list,
/// and returns a JSON representation
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
class AgentSelector extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "agentSelector"
  }
}

/// Widget that allows you to render dynamic selections driven by API retrievals
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | **`credentialType`** | | credential containing API retrieval and transformation logic | |
/// | `metadataTemplate` | | key for the portion of the credential to use for retrieving information via API | |
/// | `metadataTransformer` | | key for the portion of the credential to use for transforming the retrieved information | |
/// | `flatten` | | whether to flatten the values retrieved via API | |
/// | `strict` | | whether to strictly check the tree returned via API | |
/// | `multiSelect` | | hether multiple options can be selected (true) or only a single option (false) | |
/// | `required` | | whether a value must be selected to proceed with the UI setup | `false` |
/// | `hide` | | whether the widget will be shown in the UI (false) or not (true) | `false` |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
class APITree extends UIElement {
  fixed type = "object"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// Type of credential through which to make API calls.
  hidden credentialType: String

  /// Key for the portion of the credential to use for retrieving information via API.
  hidden metadataTemplate: String?

  /// Key for the portion of the credential to use for transforming the retrieved information.
  hidden metadataTransformer: String?

  /// Whether to flatten the values retrieved via API.
  hidden flatten: Boolean?

  /// Whether to strictly check the tree returned via API.
  hidden strict: Boolean?

  /// Whether multiple options can be selected (true) or only a single option (false).
  hidden multiSelect: Boolean?

  /// Any additional properties for the widget.
  fixed additionalProperties = new Mapping {
    ["type"] = "array"
  }.toMap()

  /// Default value for the widget.
  fixed default = "{}"

  /// Variable containing the GUID of the credential (will either be 'credential-guid' or (rarely) 'api-credential-guid')
  hidden cred: String = "credential-guid"

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "apitree"
    flattenValue = flatten
    treeCheckStrictly = strict
    connectorConfigName = credentialType
    credential = cred
    isMultiple = multiSelect
    metadataTransformerTemplateKey = metadataTransformer
    metadataTemplateKey = metadataTemplate
  }
}

/// Widget that allows you to configure multiple sub-elements all grouped together under a single parent
/// variable.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | **`inputs`** | | map of the sub-elements that should be nested within this input | |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
open class NestedInput extends UIElement {
  fixed type = "object"

  /// Whether the widget will be shown in the UI (false) or not (true).
  hidden hide: Boolean = false // Necessary for generated Kotlin copy method override

  /// Map of the sub-elements that should be nested within this input, keyed by unique lower_snake_case variable name.
  hidden inputs: Mapping<String(lower_snake_case), UIElement>

  /// (Generated) Map of properties nested within this input.
  fixed properties: Map<String, UIElement> = inputs.toMap()

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "nested"
    nestedValue = false
    `hidden` = hide
  }
}

/// Widget that executes arbitrary SQL against the connector that is being configured.
///
/// | Field | | Description | Default |
/// |---|---|---|---|
/// | **`title`** | | name to show in the UI for the widget | |
/// | **`sqlQuery`** | | query to run in the SQL executor | |
/// | `helpText` | | informational text to place in a hover-over to describe the use of the input | `""` |
/// | `width` | | sizing of the input on the UI (8 is full-width, 4 is half-width) | `8` |
class SQLExecutor extends UIElement {
  fixed type = "string"
  required: Boolean = false // Necessary for generated Kotlin copy method override

  /// Query to run in the SQL executor.
  hidden sqlQuery: String

  /// (Generated) Internal configuration for the UI's rendering.
  fixed ui {
    widget = "sql"
    query = sqlQuery
  }
}
