/* SPDX-License-Identifier: Apache-2.0
   Copyright 2024 Atlan Pte. Ltd. */

/// Module for rendering the outputs for a custom package's configuration in Atlan.
@ModuleInfo { minPklVersion = "0.25.1" }
module com.atlan.pkg.Renderers

import "Config.pkl"
import "Connectors.pkl"

/// Render the configmap YAML file.
const function getConfigMap(m: Config): FileOutput = new FileOutput {
  value = new ConfigMap {
    name = m.name
    config = m.uiConfig
  }
  renderer = new YamlRenderer {}
}

/// Render the workflow template YAML file.
const function getWorkflowTemplate(m: Config): FileOutput = new FileOutput {
  value = new WorkflowTemplate {
    name = m.name
    template = new WorkflowTemplateDefinition {
      c = m.uiConfig
      container = new WorkflowContainer {
        config = m.uiConfig
        image = m.containerImage
        command = m.command
        args = m.args
        imagePullPolicy = m.containerImagePullPolicy
      }
      outputs = m.outputs
      p = m.name
    }
  }
  renderer = new YamlRenderer {}
}

/// Render the index.js file.
const function getIndexJs(): FileOutput = new FileOutput {
  text = """
    function dummy() {
        console.log("don't call this.")
    }
    module.exports = dummy;
    """
}

/// Render the package.json file.
const function getPackageJson(m: Config): FileOutput = new FileOutput {
  value = new PackageDefinition {
    packageId = m.packageId
    packageName = m.packageName
    version = m.version.toString()
    description = m.description
    iconUrl = m.iconUrl
    docsUrl = m.docsUrl
    keywords = m.keywords
    allowSchedule = m.allowSchedule
    certified = m.certified
    preview = m.preview
    connectorType = m.connectorType
    category = m.category
  }
  renderer = new JsonRenderer {}
}

/// Render the Kotlin class file that strongly-types the configuration handover.
const function getConfigClassKt(m: Config, className: String): FileOutput = new FileOutput {
  text = new Listing {
    """
    /* SPDX-License-Identifier: Apache-2.0
       Copyright 2024 Atlan Pte. Ltd. */
    import com.atlan.model.assets.Connection
    import com.atlan.pkg.CustomConfig
    import com.atlan.pkg.model.ConnectorAndConnections
    import com.atlan.pkg.serde.WidgetSerde
    import com.fasterxml.jackson.annotation.JsonAutoDetect
    import com.fasterxml.jackson.annotation.JsonProperty
    import com.fasterxml.jackson.databind.annotation.JsonDeserialize
    import com.fasterxml.jackson.databind.annotation.JsonSerialize
    import javax.annotation.processing.Generated;

    /**
     * Expected configuration for the \(m.packageName) custom package.
     */
    @Generated("com.atlan.pkg.CustomPackage")
    @JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY)
    data class \(className)(
    """
    for (k, u in m.uiConfig.properties) {(
      if (u is Config.DropDown || u is Config.MultipleGroups || u is Config.MultipleUsers || u is Config.ConnectionSelector)
        """
            @JsonDeserialize(using = WidgetSerde.MultiSelectDeserializer::class)
            @JsonSerialize(using = WidgetSerde.MultiSelectSerializer::class)
            @JsonProperty(\"\(k)\") val \(getLowerCamelCase(k)): List<String>? = null,
        """
      else if (u is Config.ConnectorTypeSelector)
        """
            @JsonDeserialize(using = WidgetSerde.ConnectorAndConnectionsDeserializer::class)
            @JsonSerialize(using = WidgetSerde.ConnectorAndConnectionsSerializer::class)
            @JsonProperty(\"\(k)\") val \(getLowerCamelCase(k)): ConnectorAndConnections? = null,
        """
      else if (u is Config.ConnectionCreator)
        """
            @JsonDeserialize(using = WidgetSerde.ConnectionDeserializer::class)
            @JsonSerialize(using = WidgetSerde.ConnectionSerializer::class)
            @JsonProperty(\"\(k)\") val \(getLowerCamelCase(k)): Connection? = null,
        """
      else if (u is Config.BooleanInput)
        """
            @JsonProperty(\"\(k)\") val \(getLowerCamelCase(k)): Boolean? = null,
        """
      else if (u is Config.NumericInput)
        """
            @JsonProperty(\"\(k)\") val \(getLowerCamelCase(k)): Number? = null,
        """
      else if (u is Config.DateInput)
        """
            @JsonProperty(\"\(k)\") val \(getLowerCamelCase(k)): Long? = null,
        """
      else
        """
            @JsonProperty(\"\(k)\") val \(getLowerCamelCase(k)): String? = null,
        """
    )}
    """
    ) : CustomConfig()
    """
  }.join("\n")
}

const function getLowerCamelCase(s: String): String =
  s.split(Regex("[\\W_]+")).foldIndexed("", (idx, acc, word) ->
    if (idx == 0)
      "\(acc)\(word.decapitalize())"
    else
      "\(acc)\(word.capitalize())"
  )

/// Render the Python class file that strongly-types the configuration handover.
const function getConfigClassPy(m: Config): FileOutput = new FileOutput {
  // TODO: Write our own code generator(s) for the Python class
  text = new Listing {
    trace("Python class not yet implemented.")
  }.join("\n")
}

local class NamePathS3Tuple extends NamedPair {
  hidden inputName: String
  name: String = "\(inputName)_s3"
  path: String = "/tmp/\(inputName)/{{inputs.parameters.\(inputName)}}"
  s3: Mapping<String, String> = new Mapping {
    ["key"] = "{{inputs.parameters.\(inputName)}}"
  }
}

class ConfigMapEntry extends NamedPair {
  name: String
  fixed valueFrom = (value) {
    when (default != null) {
      ["default"] = default
    }
  }
  hidden configMapName: String
  hidden configMapKey: String
  hidden default: String? = null
  hidden fixed value = new Mapping {
    ["configMapKeyRef"] = new Mapping {
      ["name"] = configMapName
      ["key"] = configMapKey
    }
  }
}

class NamedSecret extends NamedPair {
  name: String
  fixed valueFrom = new Mapping {
    ["secretKeyRef"] = new Mapping {
      ["name"] = secretName
      ["key"] = secretKey
    }
  }
  hidden secretName: String
  hidden secretKey: String
}

local class NestedConfig extends NamedPair {
  name: String = "NESTED_CONFIG"
  fixed value: String = new Listing {
    if (inputs == null || inputs.isEmpty)
      "null"
    else
      "{"
    new Listing {
      for (k, ui in inputs) {
        if (ui is Config.FileUploader || ui is Config.FileCopier)
          "\"\(k)\": \"/tmp/\(k)/{{inputs.parameters.\(k)}}\""
        else if (ui is Config.NumericInput || ui is Config.DateInput || ui is Config.BooleanInput)
          "\"\(k)\": {{inputs.parameters.\(k)}}"
        else
          "\"\(k)\": {{=toJson(inputs.parameters.\(k))}}"
      }
    }.join(",\n")
    "}"
  }.join("\n")
  hidden inputs: Map<String, Config.UIElement>
}

class NameValuePair extends NamedPair {
  name: String
  value: String
}

class NamePathPair extends NamedPair {
  name: String
  path: String
}

abstract class NamedPair {
  name: String
}

/// Used to render the appropriately-wrapped output file for the UI portion of a package.
local class ConfigMap {
  fixed apiVersion = "v1"
  fixed kind = "ConfigMap"
  fixed metadata: Mapping<String, String> = new Mapping {
    ["name"] = name
  }
  fixed data: Mapping<String, String> = new Mapping {
    ["config"] = new JsonRenderer {}.renderValue(config)
  }
  hidden name: String
  hidden config: Config.UIConfig
}

local class PackageDefinition {
  hidden packageId: String
  hidden packageName: String
  fixed name: String = packageId
  version: String
  description: String
  keywords: Listing<String> = new Listing {}
  hidden iconUrl: String
  hidden docsUrl: String
  hidden allowSchedule: Boolean = true
  hidden certified: Boolean = true
  hidden preview: Boolean = false
  hidden connectorType: Connectors.Type?
  hidden category: String = "custom"
  fixed homepage: String = "https://packages.atlan.com/-/web/detail/\(packageId)"
  fixed main: String = "index.js"
  fixed scripts: Map<String, String> = Map()
  fixed author: Map<String, String> = new Mapping {
    ["name"] = "Atlan CSA"
    ["email"] = "csa@atlan.com"
    ["url"] = "https://atlan.com"
  }.toMap()
  fixed repository: Map<String, String> = new Mapping {
    ["type"] = "git"
    ["url"] = "https://github.com/atlanhq/marketplace-packages.git"
  }.toMap()
  fixed license: String = "MIT"
  fixed bugs: Map<String, String> = new Mapping {
    ["url"] = "https://atlan.com"
    ["email"] = "support@atlan.com"
  }.toMap()
  fixed config: PackageConfig = new PackageConfig {
    labels = new Mapping {
      ["orchestration.atlan.com/verified"] = "true"
      ["orchestration.atlan.com/type"] = category
      ["orchestration.atlan.com/source"] = connectorType?.value ?? "atlan"
      ["orchestration.atlan.com/sourceCategory"] = connectorType?.category ?? "utility"
      ["orchestration.atlan.com/certified"] = certified.toString()
      ["orchestration.atlan.com/preview"] = preview.toString()
    }
    annotations = new Mapping {
      ["orchestration.atlan.com/name"] = packageName
      ["orchestration.atlan.com/allowSchedule"] = allowSchedule.toString()
      ["orchestration.atlan.com/dependentPackage"] = ""
      ["orchestration.atlan.com/emoji"] = "ðŸš€"
      ["orchestration.atlan.com/categories"] = keywords.join(",")
      ["orchestration.atlan.com/icon"] = iconUrl
      ["orchestration.atlan.com/logo"] = iconUrl
      ["orchestration.atlan.com/docsUrl"] = docsUrl
    }
  }
}

local class PackageConfig {
  labels: Mapping<String, String>
  annotations: Mapping<String, String>
}

/// Used to render the appropriately-wrapped output file for the Argo hand-over portion of a package.
local class WorkflowTemplate {
  fixed apiVersion = "argoproj.io/v1alpha1"
  fixed kind = "WorkflowTemplate"
  fixed metadata = new Mapping {
    ["name"] = name
  }
  fixed spec: Map<String, List<WorkflowTemplateDefinition>> = new Mapping {
    when (fileMoves.isEmpty) {
      ["templates"] = List(template)
    } else {
      ["templates"] = List(setup, (template) { name = "process" })
    }
  }.toMap()
  hidden name: String
  hidden template: WorkflowTemplateDefinition
  hidden fileMoves: Listing<TaskDefinition> = new Listing {
    for (k, u in template.inputs.config.properties) {
      when (u is Config.FileUploader) {
        new TaskDefinition {
          name = "move-\(getSafeTaskName(k))"
          templateRef = new TemplateRef {
            name = "atlan-workflow-helpers"
            template = "move-artifact-to-s3"
          }
          condition = "'{{inputs.parameters.cloud_provider}}' == 'azure' && {{inputs.parameters.is_azure_artifacts}} == false && '{{inputs.parameters.\(k)_id}}' != ''"
          arguments = new Arguments {
            parameters = new Listing {
              new NameValuePair {
                name = "file-id"
                value = "{{inputs.parameters.\(k)_id}}"
              }
              new NameValuePair {
                name = "s3-file-key"
                value = "{{inputs.parameters.\(k)_key}}"
              }
            }.toList()
          }
        }
      }
    }
  }
  hidden setup: WorkflowTemplateDefinition? = (if (!fileMoves.isEmpty)
      new WorkflowTemplateDefinition {
        c = template.c
        dag = new WorkflowDag {
          tasks = fileMoves.toList() + new Listing {
                new TaskDefinition {
                  name = "process"
                  template = "process"
                  depends = fileMoves.toList().map((it) -> it.name).join(" && ")
                  arguments = new Arguments {
                    parameters = passthrough
                  }
                }
              }.toList()
        }
        name = "main"
        p = template.p
        f = true
      } else null)
  hidden passthrough: List<NameValuePair> = (if (!fileMoves.isEmpty) new Listing {
      new NameValuePair {
        name = S3_CONFIG_PREFIX
        value = "{{inputs.parameters.\(S3_CONFIG_PREFIX)}}"
      }
      for (k, u in template.inputs.config.properties) {
        when (u is Config.FileUploader) {
          new NameValuePair {
            name = k
            value = "{{inputs.parameters.\(k)_key}}"
          }
        } else {
          new NameValuePair {
            name = k
            value = "{{inputs.parameters.\(k)}}"
          }
        }
      }
    }.toList() else List())
}

local class WorkflowTemplateDefinition {
  name: String = "main"
  fixed inputs: WorkflowInputs = new WorkflowInputs {
    config = c
    pkgName = p
    fileInputSetup = f
  }
  outputs: Config.WorkflowOutputs?
  container: WorkflowContainer?
  dag: WorkflowDag?
  hidden c: Config.UIConfig
  hidden p: String = ""
  hidden f: Boolean = false
}

local class WorkflowInputs {
  fixed parameters: List<NamedPair> = params.toList()
  fixed artifacts: List<NamePathS3Tuple>? = if (fileInputSetup) null else arts.toList()
  hidden config: Config.UIConfig
  hidden pkgName: String = ""
  hidden fileInputSetup: Boolean = false

  hidden arts: Listing<NamePathS3Tuple> = new Listing {
    for (k, u in config.properties) {
      when (u is Config.FileUploader || u is Config.FileCopier) {
        new NamePathS3Tuple {
          inputName = k
        }
      }
    }
  }
  hidden params: Listing<NamedPair> = new Listing {
    when (!pkgName.isEmpty) {
      new NameValuePair {
        name = S3_CONFIG_PREFIX
        value = pkgName
      }
      when (fileInputSetup) {
        new ConfigMapEntry {
          name = "is_azure_artifacts"
          configMapName = "atlan-defaults"
          configMapKey = "azure_artifacts"
          default = "false"
        }
        new ConfigMapEntry {
          name = "cloud_provider"
          configMapName = "atlan-defaults"
          configMapKey = "cloud"
          default = "aws"
        }
      }
    }
    for (k, u in config.properties) {
      when (u is Config.FileUploader || u is Config.FileCopier) {
        when (fileInputSetup) {
          new NameValuePair {
            name = k
            value = "{}"
          }
          new NameValuePair {
            name = "\(k)_key"
            value = "{{= sprig.dig('fileKey', '\(DEFAULT_FILE)', sprig.mustFromJson(inputs.parameters.\(k))) }}"
          }
          new NameValuePair {
            name = "\(k)_id"
            value = "{{= sprig.dig('fileId', '', sprig.mustFromJson(inputs.parameters.\(k))) }}"
          }
        } else {
          new NameValuePair {
            name = k
            value = DEFAULT_FILE
          }
        }
      } else {
        when (u is Config.BooleanInput) {
          new NameValuePair {
            name = k
            value = u.ui.default.toString()
          }
        } else {
          when (u is Config.NumericInput || u is Config.DateInput) {
            new NameValuePair {
              name = k
              value = "-1"
            }
          } else {
            new NameValuePair {
              name = k
              value = ""
            }
          }
        }
      }
    }
  }
}

local class WorkflowDag {
  tasks: List<TaskDefinition>
}

local class TaskDefinition {
  name: String
  depends: String?
  template: String?
  templateRef: TemplateRef?
  fixed `when` = condition
  arguments: Arguments
  hidden condition: String?
}

local class TemplateRef {
  name: String
  template: String
}

local class Arguments {
  parameters: List<NamedPair>
}

local class WorkflowContainer {
  image: String
  imagePullPolicy: Config.ImagePullPolicy = "IfNotPresent"
  command: List<String>
  args: List<String> = List()
  hidden config: Config.UIConfig
  hidden defaultVars: List<NamedPair> = new Listing {
    new NameValuePair {
      name = "ATLAN_BASE_URL"
      value = "INTERNAL"
    }
    new NameValuePair {
      name = "ATLAN_USER_ID"
      value = "{{=sprig.dig('labels', 'workflows', 'argoproj', 'io/creator', '', workflow)}}"
    }
    new NameValuePair {
      name = "X_ATLAN_AGENT"
      value = "workflow"
    }
    new NameValuePair {
      name = "X_ATLAN_AGENT_ID"
      value = "{{workflow.name}}"
    }
    new NameValuePair {
      name = "X_ATLAN_AGENT_PACKAGE_NAME"
      value = "{{=sprig.dig('annotations', 'package', 'argoproj', 'io/name', '', workflow)}}"
    }
    new NameValuePair {
      name = "X_ATLAN_AGENT_WORKFLOW_ID"
      value = "{{=sprig.dig('labels', 'workflows', 'argoproj', 'io/workflow-template', '', workflow)}}"
    }
    new ConfigMapEntry {
      name = "AWS_S3_BUCKET_NAME"
      configMapName = "atlan-defaults"
      configMapKey = "bucket"
    }
    new ConfigMapEntry {
      name = "AWS_S3_REGION"
      configMapName = "atlan-defaults"
      configMapKey = "region"
    }
    new NamedSecret {
      name = "CLIENT_ID"
      secretName = "argo-client-creds"
      secretKey = "login"
    }
    new NamedSecret {
      name = "CLIENT_SECRET"
      secretName = "argo-client-creds"
      secretKey = "password"
    }
    new NamedSecret {
      name = "SMTP_HOST"
      secretName = "support-smtp-creds"
      secretKey = "host"
    }
    new NamedSecret {
      name = "SMTP_PORT"
      secretName = "support-smtp-creds"
      secretKey = "port"
    }
    new NamedSecret {
      name = "SMTP_FROM"
      secretName = "support-smtp-creds"
      secretKey = "from"
    }
    new NamedSecret {
      name = "SMTP_USER"
      secretName = "support-smtp-creds"
      secretKey = "login"
    }
    new NamedSecret {
      name = "SMTP_PASS"
      secretName = "workflow-parameter-store"
      secretKey = "smtp_password"
    }
    new ConfigMapEntry {
      name = "DOMAIN"
      configMapName = "atlan-defaults"
      configMapKey = "domain"
    }
  }.toList()
  hidden configVars: List<NamedPair> = config.properties.fold(List(), (acc: List<NamedPair>, key, property) ->
    acc.add(resolvePropertyToVar(key, property))
  )
  hidden nestedConfig: NestedConfig = new NestedConfig {
    inputs = config.properties.fold(new Mapping {}, (acc: Mapping<String, Config.UIElement>, key, property) ->
      (acc) {
        [key] = property
      }
    ).toMap()
  }
  env: List<NamedPair> = defaultVars + configVars + List(nestedConfig)
}

const function resolvePropertyToVar(key: String, property: Config.UIElement): NameValuePair = new NameValuePair {
  name = key.toUpperCase()
  value = if (property is Config.FileUploader || property is Config.FileCopier)
    new NamePathS3Tuple { inputName = key }.path
  else
    "{{inputs.parameters.\(key)}}"
}

const function getSafeTaskName(name: String): String = name.replaceAll("_", "-")
const DEFAULT_FILE = "argo-artifacts/atlan-update/@atlan-packages-last-safe-run.txt"
const S3_CONFIG_PREFIX = "output_prefix"
